<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/深入了解JAVA虚拟机/13-线程安全与锁优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/深入了解JAVA虚拟机/13-线程安全与锁优化/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>定义：当多个线程访问同一对象时，如果不考虑这些线程在运行环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其它的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p>
<p>​    按照线程安全的“安全程度”由强至弱来排序，可以将各种操作共享的数据分为：</p>
<ol>
<li>不可变</li>
<li>绝对线程安全</li>
<li>相对线程安全</li>
<li>线程兼容</li>
<li>线程对立</li>
</ol>
<h3 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h3><ol>
<li>互斥同步</li>
<li>非阻塞同步</li>
<li>无同步方案：有些代码天生就是线程安全的<ul>
<li>可重入代码</li>
<li>线程本地存储</li>
</ul>
</li>
</ol>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ol>
<li>自旋锁与自适应自旋锁</li>
<li>锁消除</li>
<li>锁粗化</li>
<li>轻量级锁：在无竞争的情况下使用CAS操作去消除同步使用的互斥量</li>
<li>偏向锁：在无竞争的情况下把整个同步都消除掉</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/深入了解JAVA虚拟机/12-java内存模型与线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/深入了解JAVA虚拟机/12-java内存模型与线程/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中读取变量这样的底层细节。</p>
<p>主内存存储所有的变量；每条线程都有独立的工作内存，保存被该线程使用到的变量的主内存拷贝。</p>
<h3 id="内存件相互操作"><a href="#内存件相互操作" class="headerlink" title="内存件相互操作"></a>内存件相互操作</h3><ul>
<li>lock</li>
<li>unlock</li>
</ul>
<ul>
<li>read：作用与主内存的变量，把一个变量的值从主内存传输到线程的工作内存中</li>
<li>load：作用于工作内存的变量，把read擦左从主内存读取到的变量值放入工作内存的变量副本中</li>
</ul>
<ul>
<li>use：作用于工作内存，把变量值传递给执行引擎</li>
<li>assign：赋值</li>
</ul>
<ul>
<li>store</li>
<li>write</li>
</ul>
<h4 id="特殊变量volatile"><a href="#特殊变量volatile" class="headerlink" title="特殊变量volatile"></a>特殊变量volatile</h4><ol>
<li>保证变量对所有线程的可见性。</li>
<li>禁止指令重排序优化。指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应的电路单元处理。能保证所有依赖赋值结果的地方都能获取到正确的结果。</li>
</ol>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>由java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write，我们基本可以认为基本数据类型的访问读写是具备原子性的。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指当一个线程修改了共享变量的值，其他线程能立即得知这个修改。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。</p>
<h3 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h3><p>先行发生是java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观测到，“影响”包括修改内存中共享变量的值、发送子信息、调用了方法等。</p>
<ol>
<li>程序次序规则</li>
<li>管程锁定规则</li>
<li>volatile变量规则</li>
<li>线程启动规则</li>
<li>线程终止规则</li>
<li>线程中断规则</li>
<li>对象终结规则</li>
<li>传递性</li>
</ol>
<h3 id="java实现线程"><a href="#java实现线程" class="headerlink" title="java实现线程"></a>java实现线程</h3><ol>
<li>使用内核线程（KLT）实现</li>
<li>使用用户线程（UT）实现</li>
<li>使用用户线程加轻量级进程（LWP）混合实现</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/深入了解JAVA虚拟机/11-运行期优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/深入了解JAVA虚拟机/11-运行期优化/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对热点代码进行编译编译成本地平台的机器码，经进行各种层次的优化，完成这个任务的编译器叫做即时编译器（JIT）。</p>
<h4 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h4><ol>
<li>当程序需要迅速启动和执行时，解释器发挥作用，省去编译的时间。</li>
<li>随着时间的推移，编译器发挥作用，把越来越多的代码代码编译成本地代码之后，可以获得更高的效率</li>
<li>当程序运行环境内存资源限制较大，可以使用<strong>解释执行节约内存，反之可以使用编译执行来提升效率</strong></li>
<li>解释器还可以作为编译器激进优化的一个“逃生门”，当出现问题时使用“逆优化”退回解释状态继续执行</li>
</ol>
<p>分层编译</p>
<ol>
<li>第0层，程序解释执行，解释器不开启性能监控功能，可触发第1层编译</li>
<li>第1层（C1编译），将字节码编译为本地代码，进行简单、可靠的优化，有必要的话可以加入性能监控的逻辑。</li>
<li>第2层（C2编译），将字节码编译为本地代码，启用一些编译耗时长优化，甚至会根据性能监控信息进行一些不可靠的优化。</li>
</ol>
<h3 id="热点代码——基于计数器的热点探测"><a href="#热点代码——基于计数器的热点探测" class="headerlink" title="热点代码——基于计数器的热点探测"></a>热点代码——基于计数器的热点探测</h3><ul>
<li>方法调用计数器</li>
</ul>
<p><img src="C:\Users\brain\Desktop\笔记\java学习\深入了解JAVA虚拟机\微信截图_20180413210732.png" alt="微信截图_20180413210732"></p>
<ul>
<li>回边计数器</li>
</ul>
<p><img src="C:\Users\brain\Desktop\笔记\java学习\深入了解JAVA虚拟机\微信截图_20180413210817.png" alt="微信截图_20180413210817"></p>
<h3 id="即时编译器经典优化技术"><a href="#即时编译器经典优化技术" class="headerlink" title="即时编译器经典优化技术"></a>即时编译器经典优化技术</h3><ol>
<li>公共子表达式消除</li>
<li>数组边界检查消除</li>
<li>方法内联</li>
<li>逃逸分析</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/深入了解JAVA虚拟机/10-类加载机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/深入了解JAVA虚拟机/10-类加载机制/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终幸好曾可以被虚拟机直接使用的java类型，这就是虚拟机的类加载机制。</p>
<p><img src="C:\Users\brain\Desktop\笔记\java学习\深入了解JAVA虚拟机\微信截图_20180412145833.png" alt="微信截图_20180412145833"></p>
<p>初始化的5种情况：</p>
<ol>
<li>遇到new、getstatic、putstatic或incokestatic这4条指令时，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果其父类没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类</li>
<li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandel实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄，并且这个句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ol>
<p>被动引用的3种情况</p>
<ol>
<li>通过子类引用父类的静态字段，不会导致子类初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li>
</ol>
<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>数组类本身不通过类加载器创建，是由java虚拟机直接创建的。但数组类的元素类型最终还是靠类加载器去创建。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ol>
<li>文件格式验证</li>
</ol>
<ul>
<li>是否以魔数开头</li>
<li>主、次版本号</li>
<li>检查常量tag标志</li>
<li>指向常量废人各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_Utf8_info类型的常量中是否有不符合UTF8编码的数据</li>
<li>class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li>
</ul>
<ol start="2">
<li>元数据验证</li>
</ol>
<ul>
<li>是否有父类</li>
<li>父类是否继承了不允许继承的类</li>
<li>如果不是抽象类，是否实现了其父类或接口中要求实现的方法</li>
<li>类中的字段、方法是否与父类产生了矛盾</li>
</ul>
<ol start="3">
<li>字节码验证</li>
</ol>
<p>通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</p>
<p>这里有一点：通过程序去校验程序逻辑是无法做到绝对准确的——不能通过程序准确地检查出程序是否能在有限的时间内结束运行。</p>
<ol start="4">
<li>符号引用验证</li>
</ol>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性是否可以被当前类访问</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量使用的内存都在<strong>方法区</strong>中分配。（类变量仅仅包括static修饰的变量；初始值是零值）</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替代为直接引用的过程。</p>
<ol>
<li>类或接口的解析</li>
<li>字段解析</li>
</ol>
<p>如果有一个同名字段同时出现在C的接口和父类中，或者同时在自己或父类的多个接口中出现，编译器将可能拒绝编译。</p>
<ol start="3">
<li>类方法解析</li>
<li>接口方法解析</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者说初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p>
<ul>
<li><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的。</clinit></li>
<li>虚拟机保证在子类的<clinit>()方法执行之前，父类ude<clinit>()方法方法已经执行完毕。</clinit></clinit></li>
<li>由于父类的<clinit>()方法先执行，则父类中的静态语句块要先于子类的变量赋值操作。</clinit></li>
<li>如果一个类没有静态语句块，则可以不为这个类生成<clinit>()方法</clinit></li>
<li>接口不能使用静态语句块，但是也有<clinit>()方法。此时的<clinit>()方法不需要执行父接口的<clinit>()方法。</clinit></clinit></clinit></li>
<li>一个类的<clinit>()方法会在多线程环境中被正确地加锁、同步。</clinit></li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>把加载阶段的“通过一个类的全限定名来获取定义此类的二进制字节流”操作放到虚拟机外部实现，实现这个动作的代码模块成为“类加载器”。</p>
<p><strong>比较两个类是否相等</strong>，只有在两个类是由同一个类加载器加载的前提下才有意义。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li>启动类加载器：使用C++实现，是虚拟机的一部分</li>
<li>所有其它的类加载器：由java语言实现，独立于虚拟机，并且全部继承自抽象类java.lang.ClassLoader</li>
</ul>
<p>划分得更细致些可以分成三种：</p>
<ol>
<li>启动类加载器</li>
<li>拓展类加载器</li>
<li>应用程序类加载器（系统类加载器）</li>
</ol>
<p><img src="C:\Users\brain\Desktop\笔记\java学习\深入了解JAVA虚拟机\微信截图_20180413203244.png" alt="微信截图_20180413203244"></p>
<p>工作过程：如果一个类加载器收到了类加载的请求，首先把这个请求提交给父类加载器执行。只有当父加载器反馈自己无法完成请求时，子加载器才会尝试自己加载。</p>
<p>加载过程：</p>
<ol>
<li>检查是否已经被加载过</li>
<li>若无，调用父加载器的加载方法</li>
<li>若父加载器为空，使用启动类加载器作为父加载器</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/深入了解JAVA虚拟机/1-JAVA内存区域/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/深入了解JAVA虚拟机/1-JAVA内存区域/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>可以看作当前线程所执行的字节码对应的行号指示器。每个线程都拥有独立的程序计数器。</p>
<ul>
<li>如果线程正在执行一个JAVA方法，计数器记录的是正在执行的虚拟机字节码指令的地址；</li>
<li>如果正在执行的是Native方法，计数器值则为空</li>
<li>这个内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的区域</li>
</ul>
<h3 id="java虚拟机栈"><a href="#java虚拟机栈" class="headerlink" title="java虚拟机栈"></a>java虚拟机栈</h3><p>虚拟机栈描述的是java方法执行的内存模型：每个方法在执行的同时都会创建一个<strong>栈帧</strong> 用于存储局部变量表、操作数栈、动态链接、方法接口等信息。方法从被调用到执行完成的过程也是栈帧从入栈到出栈的过程。</p>
<ul>
<li>java虚拟机栈是线程私有的，其生命周期与线程相同；</li>
<li><strong>局部变量表</strong>存放了编译期间可以知道的<strong>各种基本数据类型</strong>（boolean、byte、char、short、int、float、64bit{<em>long、double</em>}）、<strong>对象引用</strong>（reference类型，它不等同于对象本身，可能是只想对象起始地址的指针，也可能是只想一个代表对象的句柄或其它与此对象相关的位置）和<strong>returnAddress类型</strong>（指向一条字节码指令的地址）。</li>
<li>会抛出两种异常：StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度；OutOfMemoryError：动态扩展是无法申请到足够的内存</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li>和虚拟机栈类似，本地方法栈为虚拟机使用到的Native方法服务。</li>
</ul>
<ul>
<li>会抛出两种异常：StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度；OutOfMemoryError：动态扩展是无法申请到足够的内存</li>
</ul>
<h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><p>虚拟机启动时创建，目的是存放对象实例，垃圾收集基本都采用分代收集算法</p>
<ul>
<li>java虚拟机所管理的内存中最大的一块，被所有线程共同使用。</li>
<li>java堆中还可以细分为：新生代、老年代<ul>
<li>新生代：Eden、From Survivor、 To Survivor</li>
</ul>
</li>
<li>通过-Xmx和-Xms控制堆内存的空间分配</li>
<li>当堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出OutOfMemoryError</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<ul>
<li>所有线程共享</li>
<li>这个区域的垃圾回收目标主要针对常量池的回收和对类型的卸载</li>
<li>当方法区无法满足内存分配需求时， 将抛出OutOfMemoryError</li>
<li>运行时常量池存放编译期间生成的各种字面量和符号引用；<strong>动态性</strong>：可以在运行期间姜新的常量放入池中</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/java设计模式/设计模式的六大原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/java设计模式/设计模式的六大原则/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://wiki.jikexueyuan.com/project/java-design-pattern-principle/" target="_blank" rel="noopener">设计模式的六大原则</a></p>
<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。</p>
<p>遵循单一职责原的优点有：</p>
<ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<h1 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义 1"></a>定义 1</h2><p>如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。</p>
<h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义 2"></a>定义 2</h2><p>所有引用基类的地方必须能透明地使用其子类的对象。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>
<h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p>
<h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。</p>
<h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，则会大大降低修改类A的几率。</p>
<h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的”契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>一个对象应该对其他对象保持最少的了解。</p>
<h2 id="问题由来-1"><a href="#问题由来-1" class="headerlink" title="问题由来"></a>问题由来</h2><p>类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
<h2 id="问题由来-2"><a href="#问题由来-2" class="headerlink" title="问题由来"></a>问题由来</h2><p>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/java设计模式/工厂模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/java设计模式/工厂模式/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface Shape&#123;</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class circleShape implements Shape&#123;</span><br><span class="line">	public circleShape()&#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    void draw()&#123;</span><br><span class="line">        print(circle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class RectShape implements Shape&#123;</span><br><span class="line">	public RectShape()&#123;&#125;</span><br><span class="line">    @Override</span><br><span class="line">    void draw()&#123;</span><br><span class="line">        print(Rect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>定义<strong>一个</strong>工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory &#123;</span><br><span class="line">    public static final String TAG = &quot;ShapeFactory&quot;;</span><br><span class="line">    public static Shape getShape(String type) &#123;</span><br><span class="line">    	Shape shape = null;</span><br><span class="line">        if (type.equalsIgnoreCase(&quot;circle&quot;)) &#123;</span><br><span class="line">        	shape = new CircleShape();</span><br><span class="line">        &#125; else if (type.equalsIgnoreCase(&quot;rect&quot;)) &#123;</span><br><span class="line">        	shape = new RectShape();</span><br><span class="line">        &#125; else if (type.equalsIgnoreCase(&quot;triangle&quot;)) &#123;</span><br><span class="line">        	shape = new TriangleShape();</span><br><span class="line">        &#125;</span><br><span class="line">    return shape;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">interface ShapeFactory&#123;</span><br><span class="line">    Shape getShape();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class circleShapeFactory implements ShapeFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape()&#123;</span><br><span class="line">        return new circleShape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class rectShapeFactory implements ShapeFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape()&#123;</span><br><span class="line">        return new rectShape();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用过程</span><br><span class="line">ShapeFactory circlefatory = new circleShapeFactory();</span><br><span class="line">Circle cirlce = factory.getShape();</span><br><span class="line">circle.draw();</span><br></pre></td></tr></table></figure>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>​    这个模式最不好理解，而且在实际应用中局限性也蛮大的，因为这个模式并不符合开闭原则。实际开发还需要做好权衡。<br>　　抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一个对象，而是可以创建一组对象。这是和工厂方法最大的不同点。</p>
<p><strong>定义：</strong><br>　　提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。（ 在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的对象）<br>　　<br>抽象工厂和工厂方法一样可以划分为4大部分：<br>AbstractFactory（抽象工厂）声明了一组用于创建对象的方法，注意是一组。<br>ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建对象的方法，生成一组具体对象。<br>AbstractProduct（抽象产品）：它为每种对象声明接口，在其中声明了对象所具有的业务方法。<br>ConcreteProduct（具体产品）：它定义具体工厂生产的具体对象。<br>下面还是先看一个具体实例。</p>
<p><strong>实例：</strong><br>　　现在需要做一款跨平台的游戏，需要兼容Android，Ios，Wp三个移动操作系统，该游戏针对每个系统都设计了一套操作控制器（OperationController）和界面控制器（UIController），下面通过抽闲工厂方式完成这款游戏的架构设计。</p>
<p>　　由题可知，游戏里边的各个平台的UIController和OperationController应该是我们最终生产的具体产品。所以新建两个抽象产品接口。</p>
<p>抽象操作控制器、抽象界面控制器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface OperationController &#123;</span><br><span class="line">    void control();</span><br><span class="line">&#125;</span><br><span class="line">public interface UIController &#123;</span><br><span class="line">    void display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后完成各个系统平台的具体操作控制器和界面控制器<br>Android</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AndroidOperationController implements OperationController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void control() &#123;</span><br><span class="line">        System.out.println(&quot;AndroidOperationController&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AndroidUIController implements UIController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;AndroidInterfaceController&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ios</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class IosOperationController implements OperationController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void control() &#123;</span><br><span class="line">        System.out.println(&quot;IosOperationController&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class IosUIController implements UIController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;IosInterfaceController&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Wp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class WpOperationController implements OperationController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void control() &#123;</span><br><span class="line">        System.out.println(&quot;WpOperationController&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class WpUIController implements UIController &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;WpInterfaceController&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面定义一个抽闲工厂，该工厂需要可以创建OperationController和UIController</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface SystemFactory &#123;</span><br><span class="line">    public OperationController createOperationController();</span><br><span class="line">    public UIController createInterfaceController();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在各平台具体的工厂类中完成操作控制器和界面控制器的创建过程</p>
<p>Android</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AndroidFactory implements SystemFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OperationController createOperationController() &#123;</span><br><span class="line">        return new AndroidOperationController();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UIController createInterfaceController() &#123;</span><br><span class="line">        return new AndroidUIController();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ios</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class IosFactory implements SystemFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OperationController createOperationController() &#123;</span><br><span class="line">        return new IosOperationController();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UIController createInterfaceController() &#123;</span><br><span class="line">        return new IosUIController();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Wp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class WpFactory implements SystemFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public OperationController createOperationController() &#123;</span><br><span class="line">        return new WpOperationController();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UIController createInterfaceController() &#123;</span><br><span class="line">        return new WpUIController();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SystemFactory mFactory;</span><br><span class="line">UIController interfaceController;</span><br><span class="line">OperationController operationController;</span><br><span class="line"></span><br><span class="line">//Android</span><br><span class="line">mFactory=new AndroidFactory();</span><br><span class="line">//Ios</span><br><span class="line">mFactory=new IosFactory();</span><br><span class="line">//Wp</span><br><span class="line">mFactory=new WpFactory();</span><br><span class="line"></span><br><span class="line">interfaceController=mFactory.createInterfaceController();</span><br><span class="line">operationController=mFactory.createOperationController();</span><br><span class="line"></span><br><span class="line">interfaceController.display();</span><br><span class="line">operationController.control();</span><br></pre></td></tr></table></figure>
<p>针对不同平台只通过创建不同的工厂对象就完成了操作和UI控制器的创建。小伙伴们可以对比一下，如果这个游戏使用工厂方法模式搭建需要创建多少个工厂类呢？下面总结一下抽象工厂的适用场景。</p>
<p><strong>适用场景：</strong><br>（1）和工厂方法一样客户端不需要知道它所创建的对象的类。<br>（2）需要一组对象共同完成某种功能时。并且可能存在多组对象完成不同功能的情况。<br>（3）系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/java设计模式/单例模式的七种写法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/java设计模式/单例模式的七种写法/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>饿汉模式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">   	<span class="keyword">return</span> instance;  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在类加载阶段就开始了初始化，类加载较慢，但获取对象的速度快。这种方式基于类加载机制避免了多线程的同步问题。</p>
<ol start="2">
<li>懒汉模式（线程不安全）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在用户第一次调用实例对象时进行初始化。</p>
<ol start="3">
<li>懒汉模式（线程安全）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在getInstance()方法加上synchronized锁，每次调用对象都是线程安全的。但是会造成很多不必要的开销。</p>
<ol start="4">
<li>双重检查模式（DCL）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">					instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次判定空值是为了避免不必要的同步开销，第二次是在Singleton为null的情况下进行初始化。这里使用了volatile关键字。</p>
<ol start="5">
<li>静态内部类单例模式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title">SingleHolder</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。</p>
<ol start="6">
<li>枚举单例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认枚举单例的创建是线程安全的，并在任何情况下都是单例的。</p>
<h4 id="在以上几种单例模式中，都是可以通过反序列化来重新创建对象。"><a href="#在以上几种单例模式中，都是可以通过反序列化来重新创建对象。" class="headerlink" title="在以上几种单例模式中，都是可以通过反序列化来重新创建对象。"></a>在以上几种单例模式中，都是可以通过反序列化来重新创建对象。</h4><p>反序列化操作提供了readResolve()方法来控制反序列化。如果要杜绝反序列化的影响，要加入下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>使用容器实现单例模式</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; objMap = <span class="keyword">new</span> Map&lt;String, Object&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">regiserService</span><span class="params">(String key, Object instance)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!objMap.container(key))&#123;</span><br><span class="line">			objMap.put(key, isntance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title">ObjectgetService</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> objMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingletonManager类来管理多个单例，使用时通过key来获取对应的单例对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/java设计模式/代理模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/java设计模式/代理模式/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>[Demo](https://blog.csdn.net/mine_song/article/details/71373305)
</code></pre><p>某个对象提供一个代理，以控制对这个对象的访问。 代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。   </p>
<p><img src="1537973949091.png" alt="1537973949091"></p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><ul>
<li>在程序运行前，它的.class文件就已经存在了。</li>
</ul>
<p>由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。 </p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul>
<li>动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java反射机制可以生成任意类型的动态代理类。java.lang.reflect 包中的Proxy类和InvocationHandler接口提供了生成动态代理类的能力。</li>
</ul>
<p>在调用某个方法前及方法后做一些额外的业务。换一种思路就是：在触发（invoke）真实角色的方法之前或者之后做一些额外的业务。那么，为了构造出具有通用性和简单性的代理类，可以将所有的触发真实角色动作交给一个触发的管理器，让这个管理器统一地管理触发。这种管理器就是Invocation Handler。</p>
<p>以上是通过实现接口进行动态代理，还有一种是通过继承类来实现动态代理（cglib）</p>
<p><img src="1537974010537.png" alt="1537974010537"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/java设计模式/MVC&MVP&MVVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/java设计模式/MVC&MVP&MVVM/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>MVC</strong></p>
<p>M：Model，用来处理业务逻辑</p>
<p>V：View，专注页面布局和数据显示</p>
<p>C：Controller， 翻译用户的输入，操作模型和视图</p>
<p><img src="MVC.png" alt="MVC"></p>
<p>缺点：</p>
<ul>
<li>依赖太多<ul>
<li>View依赖Controller和Model</li>
<li>Controller依赖View和Model</li>
</ul>
</li>
</ul>
<p><strong>MVP</strong></p>
<p><img src="MVP.png" alt="MVP"></p>
<p>但是Presenter还是对View有依赖，然后出现MVP2.0</p>
<p><img src="MVP2.png" alt></p>
<p><strong>MVVM</strong></p>
<p>告诉View一个数据结构，View根据这个数据结构的变化而变化。</p>
<p>ViewModel：与View绑定</p>
<p><img src="MVVM.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">李楚豪的博客</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">85</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李楚豪的博客</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
