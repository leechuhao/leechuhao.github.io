<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/java设计模式/java设计模式之二适配器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/java设计模式/java设计模式之二适配器模式/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol start="6">
<li>适配器模式（Adapter）<br>适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。</li>
</ol>
<ul>
<li>类的适配器模式<br>在source类中重写接口的方法，在adapter中不必重写</li>
<li>对象的适配器模式<br>在adapter类中持有source类的实例</li>
<li>接口的适配器模式<br>接口中可以存在很多方法，但不是所有的方法都被需要。看可以用一个抽象类实现接口，即重写所有的方法，使用时直接调用抽象类中的方法（所以为什么要这个接口，直接写个类不可以吗？）</li>
</ul>
<hr>
<ul>
<li>类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</li>
<li>对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</li>
<li>接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</li>
</ul>
<ol start="7">
<li>装饰模式（Decorator）<br>装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，</li>
</ol>
<ul>
<li>特点：动态添加、撤除新功能</li>
</ul>
<ol start="8">
<li><p>代理模式（Proxy）<br>代理模式的应用场景：如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：</p>
<ul>
<li>修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。</li>
<li>就是采用一个代理类调用原有的方法，且对产生的结果进行控制。</li>
</ul>
</li>
<li><p>外观模式（Facade）<br>外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口</p>
</li>
<li><p>桥接模式（Bridge）<br>桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。</p>
</li>
<li><p>组合模式（Composite）<br>在处理类似树形结构的问题时比较方便</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;  </span><br><span class="line">    private String name;  </span><br><span class="line">    private TreeNode parent;  </span><br><span class="line">    private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;();  </span><br><span class="line">      </span><br><span class="line">    public TreeNode(String name)&#123;  </span><br><span class="line">        this.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    public String getName() &#123;  </span><br><span class="line">        return name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void setName(String name) &#123;  </span><br><span class="line">        this.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public TreeNode getParent() &#123;  </span><br><span class="line">        return parent;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public void setParent(TreeNode parent) &#123;  </span><br><span class="line">        this.parent = parent;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    //添加孩子节点  </span><br><span class="line">    public void add(TreeNode node)&#123;  </span><br><span class="line">        children.add(node);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    //删除孩子节点  </span><br><span class="line">    public void remove(TreeNode node)&#123;  </span><br><span class="line">        children.remove(node);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    //取得孩子节点  </span><br><span class="line">    public Enumeration&lt;TreeNode&gt; getChildren()&#123;  </span><br><span class="line">        return children.elements();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">///////////////////////////////////////</span><br><span class="line">public class Tree &#123;  </span><br><span class="line"></span><br><span class="line">    TreeNode root = null;  </span><br><span class="line"></span><br><span class="line">    public Tree(String name) &#123;  </span><br><span class="line">        root = new TreeNode(name);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Tree tree = new Tree(&quot;A&quot;);  </span><br><span class="line">        TreeNode nodeB = new TreeNode(&quot;B&quot;);  </span><br><span class="line">        TreeNode nodeC = new TreeNode(&quot;C&quot;);  </span><br><span class="line">          </span><br><span class="line">        nodeB.add(nodeC);  </span><br><span class="line">        tree.root.add(nodeB);  </span><br><span class="line">        System.out.println(&quot;build the tree finished!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>享元模式（Flyweight）<br>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。<br>适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/java设计模式/java设计模式之三行为型模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/java设计模式/java设计模式之三行为型模式/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>行为型模式<br>分为三类：<br>一、父类和子类之间</p>
<ol start="13">
<li>策略模式（strategy）<br>定义一些算法，封装起来，并且这些算法可以互相替换。最典型的是计算器。</li>
<li>模板方法模式（Template Method）<br>一个抽象类中，有一个主方法（主要的方法），再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用.</li>
</ol>
<p>二、两个类之间</p>
<ol start="15">
<li><p>观察者模式（Observer）<br>当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。</p>
</li>
<li><p>迭代子模式（Iterator）<br>集合</p>
</li>
<li><p>责任链模式（Chain of Responsibility）<br>有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。（命令只允许由一个对象传给另一个对象，而不允许传给多个对象）</p>
</li>
<li><p>命令模式（Command）<br>命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开</p>
</li>
</ol>
<p>三、类的状态</p>
<ol start="19">
<li><p>备忘录模式（Memento）<br>有一个类中某个属性需要备份，创建了备份类和启动备份类。</p>
</li>
<li><p>状态模式（State）<br>可以通过改变状态来获得不同的行为；你的好友能同时看到你的变化。</p>
</li>
</ol>
<p>四、通过中间类</p>
<ol start="21">
<li><p>访问者模式（Visitor）<br>访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果</p>
</li>
<li><p>中介者模式（Mediator）<br>中介类实现其它类并持有实例，解释说中介实现所有方法，其他类只要写好并放在中介。</p>
</li>
<li><p>解释器模式（Interpreter）</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/java设计模式/java设计模式之一创建型模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/java设计模式/java设计模式之一创建型模式/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><ol>
<li>工厂方法模式（Factory Method）</li>
</ol>
<ul>
<li>普通工厂模式</li>
<li>多个工厂方法模式：在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。</li>
<li>静态工厂方法模式<br>总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。</li>
</ul>
<ol start="2">
<li><p>抽象工厂模式（Abstract Factory）<br>这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！</p>
</li>
<li><p>单例模式（Singleton）<br>在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p>
</li>
</ol>
<ul>
<li>某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</li>
<li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</li>
<li>有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">	/* 私有构造方法，防止被实例化 */</span><br><span class="line">	private Singleton() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	/* 此处使用一个内部类来维护单例 */</span><br><span class="line">	private static class SingletonFactory &#123;</span><br><span class="line">	private static Singleton instance = new Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	/* 获取实例 */</span><br><span class="line">	public static Singleton getInstance() &#123;</span><br><span class="line">	  return SingletonFactory.instance;</span><br><span class="line">	  &#125;</span><br><span class="line">	  /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span><br><span class="line">	  public Object readResolve() &#123;</span><br><span class="line">	  return getInstance();</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>4、建造者模式（Builder）<br>建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。</p>
<p>5、原型模式（Prototype）<br>该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">	public class Prototype implements Cloneable, Serializable &#123;</span><br><span class="line">	private static final long serialVersionUID = 1L;</span><br><span class="line">	private String string;</span><br><span class="line">	private SerializableObject obj;</span><br><span class="line">	</span><br><span class="line">	/* 浅复制 */</span><br><span class="line">	public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">		Prototype proto = (Prototype) super.clone();</span><br><span class="line">		return proto;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/* 深复制 */</span><br><span class="line">	public Object deepClone() throws IOException, ClassNotFoundException &#123;</span><br><span class="line">	</span><br><span class="line">		/* 写入当前对象的二进制流 */</span><br><span class="line">		ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">		ObjectOutputStream oos = new ObjectOutputStream(bos);</span><br><span class="line">		oos.writeObject(this);</span><br><span class="line">	</span><br><span class="line">		/* 读出二进制流产生的新对象 */</span><br><span class="line">		ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">		ObjectInputStream ois = new ObjectInputStream(bis);</span><br><span class="line">		return ois.readObject();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public String getString() &#123;</span><br><span class="line">		return string;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void setString(String string) &#123;</span><br><span class="line">		this.string = string;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public SerializableObject getObj() &#123;</span><br><span class="line">		return obj;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void setObj(SerializableObject obj) &#123;</span><br><span class="line">		this.obj = obj;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SerializableObject implements Serializable &#123;</span><br><span class="line">	private static final long serialVersionUID = 1L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/测试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/测试/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试对源程序中每一个程序单元进行测试，检查各个<strong>模块</strong>是否正确实现规定的功能，从而发现模块在编码中或算法中的错误。该阶段涉及编码和详细设计文档。</p>
<h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><p>系统测试是基于软件需求说明书的<strong>黑盒测试</strong>，是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等满足其规约所指定的要求，检查软件的行为和输出是否正确</p>
<h3 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h3><p>确认测试主要是检查已实现的软件<strong>是否满足需求</strong>规格说明书中确定了的各种需求。</p>
<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>集成测试的主要目的是检查软件单位之间的接口是否正确，主要是针对程序内部结构进行测试，特别是对程序之间的接口进行测试。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>单元–&gt;集成–&gt;系统–&gt;确认</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/操作符优先级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/操作符优先级/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>结合性</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>[ ] . ( ) (方法调用)</td>
<td>从左向右</td>
</tr>
<tr>
<td>! ~ ++ – +(一元运算) -(一元运算)</td>
<td>从右向左</td>
</tr>
<tr>
<td>* / %</td>
<td>从左向右</td>
</tr>
<tr>
<td>+ -</td>
<td>从左向右</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td>从左向右</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;= instanceof</td>
<td>从左向右</td>
</tr>
<tr>
<td>== !=</td>
<td>从左向右</td>
</tr>
<tr>
<td>&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>^</td>
<td>从左向右</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>从左向右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>从左向右</td>
</tr>
<tr>
<td>?:</td>
<td>从右向左</td>
</tr>
<tr>
<td>=</td>
<td>从右向左</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/垃圾回收/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/垃圾回收/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>GC原理</strong>：GC机制对JVM的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动回收内幕才能，以保证JVM中的内存空间，防止出现内存泄漏和溢出问题。</p>
<p>垃圾回收包含的内容不少，但顺着下面的顺序捋清知识也并不难。首先要搞清垃圾回收的范围（栈需要GC去回收吗？），然后就是回收的前提条件如何判断一个对象已经可以被回收（这里只重点学习根搜索算法就行了），之后便是建立在根搜索基础上的三种回收策略，最后便是JVM中对这三种策略的具体实现。</p>
<p><strong>1.范围：要回收哪些区域？</strong></p>
<p>​    Java方法栈、本地方法栈以及PC计数器<strong>随方法或线程的结束而自然被回收</strong>，所以这些区域不需要考虑回收问题。Java堆和方法区是GC回收的重点区域，因为一个接口的多个实现类需要的内存不一样，一个方法的多个分支需要的内存可能也不一样，而这两个区域又对立于栈可能随时都会有对象不再被引用，因此这部分内存的<strong>分配和回收</strong>都是动态的。</p>
<p><strong>2.前提：如何判断对象已死？</strong></p>
<p><strong>（1）引用计数法</strong></p>
<p>​    引用计数法就是通过一个计数器记录该对象被引用的次数，方法简单高效，但是解决不了<strong>循环引用</strong>的问题。比如对象A包含指向对象B的引用，对象B也包含指向对象A的引用，但没有引用指向A和B，这时当前回收如果采用的是引用计数法，那么对象A和B的被引用次数都为1，都不会被回收。下面是循环引用的例子，在Hotspot JVM下可以被正常回收，可以证实JVM采用的不是简单的引用计数法。通过-XX:+PrintGCDetails输出GC日志。</p>
<pre><code>package com.cdai.jvm.gc;
public class ReferenceCount {
    final static int MB = 1024 * 1024；
    byte[] size = new byte[2 * MB];
    Object ref;

    public static void main(String[] args) {
        ReferenceCount objA = new ReferenceCount();
        ReferenceCount objB = new ReferenceCount();
        objA.ref = objB;
        objB.ref = objA;

        objA = null;
        objB = null;

        System.gc();
        System.gc();
    }
}
</code></pre><p><strong>（2）根搜索</strong></p>
<p>​    通过选取一些<strong>根对象</strong>作为起始点，开始向下搜索，如果一个对象到根对象不可达时，则说明此对象已经没有被引用，是可以被回收的。可以作为根的对象有：<strong>栈中变量引用的对象，类静态属性引用的对象，常量引用的对象</strong>等。因为每个线程都有一个栈，所以我们需要选取多个根对象。</p>
<p><strong>附：对象复活</strong></p>
<p>在根搜索中得到的不可达对象并不是立即就被标记成可回收的，而是先进行<strong>一次</strong>标记放入F-Queue等待执行对象的finalize()方法，执行后GC将进行<strong>二次</strong>标记，复活的对象之后将不会被回收。因此，使对象复活的唯一办法就是重写finalize()方法，并使对象重新被引用。</p>
<p><img src="http://img.my.csdn.net/uploads/201209/02/1346554910_4185.png" alt="img"></p>
<pre><code>package com.cdai.jvm.gc;
public class DeadToRebirth {
    private static DeadToRebirth hook; 
    @Override
    public void finalize() throws Throwable {
        super.finalize();
        DeadToRebirth.hook = this;
    }

    public static void main(String[] args) throws Exception {
        DeadToRebirth.hook = new DeadToRebirth();
        DeadToRebirth.hook = null;
        System.gc();
        Thread.sleep(500);
        if (DeadToRebirth.hook != null)
            System.out.println(&quot;Rebirth!&quot;);
        else
            System.out.println(&quot;Dead!&quot;);

        DeadToRebirth.hook = null;
        System.gc();
        Thread.sleep(500);
        if (DeadToRebirth.hook != null)
            System.out.println(&quot;Rebirth!&quot;);
        else
            System.out.println(&quot;Dead!&quot;);
    }
}
</code></pre><p>要注意的两点是：</p>
<p>第一，finalize()方法只会被执行一次，所以对象只有一次复活的机会。</p>
<p>第二，执行GC后，要停顿半秒等待优先级很低的finalize()执行完毕。</p>
<p><strong>3.策略：垃圾回收的算法</strong></p>
<p><strong>（1）标记-清除</strong></p>
<p>没错，这里的标记指的就是之前我们介绍过的两次标记过程。标记完成后就可以对标记为垃圾的对象进行回收了。怎么样，简单吧。但是这种策略的缺点很明显，回收后<strong>内存碎片</strong>很多，如果之后程序运行时申请大内存，可能会又导致一次GC。虽然缺点明显，这种策略却是后两种策略的基础。正因为它的缺点，所以促成了后两种策略的产生。</p>
<p><img src="http://img.my.csdn.net/uploads/201209/02/1346555170_6180.png" alt="img"></p>
<p><strong>（2）标记-复制</strong></p>
<p>将内存分为两块，标记完成开始回收时，将一块内存中保留的对象全部复制到另一块空闲内存中。实现起来也很简单，当大部分对象都被回收时这种策略也很高效。但这种策略也有缺点，可用内存变为一半了！怎样解决呢？聪明的程序员们总是办法多过问题的。可以将堆不按1:1的比例分离，而是按8:1:1分成一块Eden和两小块Survivor区，每次将Eden和Survivor中存活的对象复制到另一块空闲的Survivor中。这三块区域并不是堆的全部，而是构成了<strong>新生代</strong>。</p>
<p>从下图可以看到这三块区域如何配合完成GC的，具体的对象空间分配以及晋升请</p>
<p>参加后面第6条补充。</p>
<p><img src="http://img.my.csdn.net/uploads/201209/02/1346555212_7344.png" alt="img"></p>
<p>​    为什么不是全部呢？如果回收时，空闲的那一小块Survivor不够用了怎么办？这就是<strong>老年代</strong>的用处。当不够用时，这些对象将直接通过<strong>分配担保</strong>机制进入老年代。那么老年代也使用标记-复制策略吧？当然不行！老年代中的对象可不像新生代中的，每次回收都会清除掉大部分。如果贸然采用复制的策略，老年代的回收效率可想而知。</p>
<p><strong>（3）标记-整理</strong></p>
<p>根据老年代的特点，采用回收掉垃圾对象后对内存进行整理的策略再合适不过，将所有存活下来的对象都向一端移动。</p>
<p><strong>4.实现：虚拟机中的收集器</strong></p>
<p><strong>（1）新生代上的GC实现</strong></p>
<p><strong>Serial</strong>：单线程的收集器，只使用一个线程进行收集，并且收集时会暂停其他所有工作线程（Stop the world）。它是Client模式下的默认新生代收集器。</p>
<p><strong>ParNew</strong>：Serial收集器的多线程版本。在单CPU甚至两个CPU的环境下，由于线程交互的开销，无法保证性能超越Serial收集器。</p>
<p><strong>Parallel Scavenge</strong>：也是多线程收集器，与ParNew的区别是，它是<strong>吞吐量</strong>优先收集器。吞吐量=运行用户代码时间/(运行用户代码+垃圾收集时间)。另一点区别是配置-XX:+UseAdaptiveSizePolicy后，虚拟机会自动调整Eden/Survivor等参数来提供用户所需的吞吐量。我们需要配置的就是内存大小-Xmx和吞吐量GCTimeRatio。</p>
<p><strong>（2）老年代上的GC实现</strong></p>
<p><strong>Serial Old</strong>：Serial收集器的老年代版本。</p>
<p><strong>Parallel Old</strong>：Parallel Scavenge的老年代版本。此前，如果新生代采用PS GC的话，老年代只有Serial Old能与之配合。现在有了Parallel Old与之配合，可以在注重吞吐量及CPU资源敏感的场合使用了。</p>
<p><strong>CMS</strong>：采用的是<strong>标记-清除</strong>而非标记-整理，是一款并发低停顿的收集器。但是由于采用标记-清除，内存碎片问题不可避免。可以使用-XX:CMSFullGCsBeforeCompaction设置执行几次CMS回收后，跟着来一次内存碎片整理。</p>
<p><strong>5.触发：何时开始GC？</strong></p>
<p>Minor GC（新生代回收）的触发条件比较简单，Eden空间不足就开始进行Minor GC回收新生代。而Full GC（老年代回收，一般伴随一次Minor GC）则有几种触发条件：</p>
<p>（1）老年代空间不足</p>
<p>（2）PermSpace空间不足</p>
<p>（3）统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间</p>
<p>这里注意一点：PermSpace并不等同于方法区，只不过是Hotspot JVM用PermSpace来实现方法区而已，有些虚拟机没有PermSpace而用其他机制来实现方法区。</p>
<p><strong>6.补充：对象的空间分配和晋升</strong></p>
<p>（1）对象优先在Eden上分配</p>
<p>（2）大对象直接进入老年代</p>
<p>虚拟机提供了-XX:PretenureSizeThreshold参数，大于这个参数值的对象将直接分配到老年代中。因为新生代采用的是标记-复制策略，在Eden中分配大对象将会导致Eden区和两个Survivor区之间大量的内存拷贝。</p>
<p>（3）长期存活的对象将进入老年代对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁）时，就会晋升到老年代中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/内存溢出和内存泄漏的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/内存溢出和内存泄漏的区别/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>内存溢出就是内存越界。内存越界有一种很常见的情况是调用栈溢出（即stackoverflow），虽然这种情况可以看成是栈内存不足的一种体现。但内存溢出并不一定跟内存分配有什么关系，因为还有一种情况是缓冲区溢出。</p>
<p>内存泄露是指你的应用使用资源之后没有及时释放，导致应用内存中持有了不需要的资源，这是一种状态描述</p>
<hr>
<p>内存泄漏是申请的空间没有及时释放或者干脆丢了指针没法释放.不是泄漏,是漏不出来;只是泄漏的内存远小于可分配的内存时影响不大,多了就玩完.</p>
<pre><code>比如你想买1000块的东西,你资产正好1000,但是有张银行卡密码忘记了,钱取不出来没法用,但是你明明有钱,不过如果那卡里只有1块钱,跟老板讲价也能买,影响不大,但是取不出来的钱多了,那就玩完.
</code></pre><p>代码的话:比如c++,new申请的空间必须delete释放,下面这么搞,没有释放,就测漏了.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> aClass();<span class="comment">//然后你就不管了,这块内存就没法释放</span></span><br></pre></td></tr></table></figure>
<p>　　内存溢出就是申请的内存超过了可用内存,内存不够用了,比如申请了10m的内存,但是一共只有5m,申请不了,就溢出了.</p>
<pre><code>还是买东西,1000块的东西,穷得嗝屁,根本没那么多钱,买不了.

代码的话:比如java,他会自动回收内存,泄漏的可能性小,但是像下面这么搞
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">1000000000000000000000</span>];<span class="comment">//一般机器程序就炸了</span></span><br></pre></td></tr></table></figure>
<p>作者：戴帽子的狗</p>
<p>链接：<a href="https://www.zhihu.com/question/40560123/answer/87150880" target="_blank" rel="noopener">https://www.zhihu.com/question/40560123/answer/87150880</a></p>
<p>来源：知乎</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/乐观锁与悲观锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/乐观锁与悲观锁/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a><a href="https://juejin.im/post/5b4977ae5188251b146b2fc8" target="_blank" rel="noopener">来源</a></h1><h4 id="悲观锁（Pessimistic-Lock）"><a href="#悲观锁（Pessimistic-Lock）" class="headerlink" title="悲观锁（Pessimistic Lock）"></a>悲观锁（Pessimistic Lock）</h4><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<h4 id="乐观锁（Optimistic-Lock）"><a href="#乐观锁（Optimistic-Lock）" class="headerlink" title="乐观锁（Optimistic Lock）"></a>乐观锁（Optimistic Lock）</h4><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>，像数据库提供的类似于<strong>write_condition机制</strong>，其实都是提供的乐观锁。在Java中<code>java.util.concurrent.atomic</code>包下面的原子变量类就是使用了乐观锁的一种实现方式<strong>CAS</strong>实现的。</p>
<h4 id="两种锁的使用场景"><a href="#两种锁的使用场景" class="headerlink" title="两种锁的使用场景"></a>两种锁的使用场景</h4><p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p>
<h4 id="乐观锁常见的两种实现方式"><a href="#乐观锁常见的两种实现方式" class="headerlink" title="乐观锁常见的两种实现方式"></a>乐观锁常见的两种实现方式</h4><h5 id="1-版本号机制"><a href="#1-版本号机制" class="headerlink" title="1. 版本号机制"></a>1. 版本号机制</h5><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<h5 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h5><p>即<strong>compare and swap（比较与交换）</strong>，是一种有名的<strong>无锁算法</strong>。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。<strong>CAS算法</strong>涉及到三个操作数</p>
<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个<strong>自旋操作</strong>，即<strong>不断的重试</strong>。</p>
<h4 id="乐观锁的缺点"><a href="#乐观锁的缺点" class="headerlink" title="乐观锁的缺点"></a>乐观锁的缺点</h4><h5 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1 ABA 问题"></a>1 ABA 问题</h5><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 <strong>“ABA”问题。</strong></p>
<p>JDK 1.5 以后的 <code>AtomicStampedReference 类</code>就提供了此种能力，其中的 <code>compareAndSet 方法</code>就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h5 id="2-循环时间长开销大"><a href="#2-循环时间长开销大" class="headerlink" title="2 循环时间长开销大"></a>2 循环时间长开销大</h5><p><strong>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</strong> 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h5 id="3-只能保证一个共享变量的原子操作"><a href="#3-只能保证一个共享变量的原子操作" class="headerlink" title="3 只能保证一个共享变量的原子操作"></a>3 只能保证一个共享变量的原子操作</h5><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了<code>AtomicReference类</code>来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference类</code>把多个共享变量合并成一个共享变量来操作。</p>
<h4 id="CAS与synchronized的使用情景"><a href="#CAS与synchronized的使用情景" class="headerlink" title="CAS与synchronized的使用情景"></a>CAS与synchronized的使用情景</h4><blockquote>
<p><strong>简单的来说CAS适用于写比较少的情况下（多读场景，冲突一般较少），synchronized适用于写比较多的情况下（多写场景，冲突一般较多）</strong></p>
</blockquote>
<ol>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
</ol>
<p>补充： Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 <strong>“重量级锁”</strong> 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 <strong>偏向锁</strong> 和 <strong>轻量级锁</strong> 以及其它<strong>各种优化</strong>之后变得在某些情况下并不是那么重了。synchronized的底层实现主要依靠 <strong>Lock-Free</strong> 的队列，基本思路是 <strong>自旋后阻塞</strong>，<strong>竞争切换后继续竞争锁</strong>，<strong>稍微牺牲了公平性，但获得了高吞吐量</strong>。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/NIO、BIO、AIO等/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/NIO、BIO、AIO等/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="区分网络IO与磁盘IO"><a href="#区分网络IO与磁盘IO" class="headerlink" title="区分网络IO与磁盘IO"></a>区分网络IO与磁盘IO</h4><p>在网络IO中，read、write等操作会因为数据没有就绪而进入“Blocking”，但是对于磁盘IO来说，不会进入Block。</p>
<p>所以现如今讨论的IO优化多是网络IO。</p>
<h3 id="BIO（Blocking-IO）"><a href="#BIO（Blocking-IO）" class="headerlink" title="BIO（Blocking IO）"></a>BIO（Blocking IO）</h3><p><img src="640.png" alt="img"></p>
<p>在类似于网络中进行read, write, connect一类的系统调用时会被卡住。</p>
<p>举个例子，当用read去读取网络的数据时，是无法预知对方是否已经发送数据的。因此在收到数据之前，能做的只有等待，直到对方把数据发过来，或者等到网络超时。</p>
<p>对于单线程的网络服务，这样做就会有卡死的问题。因为当等待时，整个线程会被挂起，无法执行，也无法做其他的工作。</p>
<!--此处的挂起指的是当前进程被挂起，不影响其他程序的运行-->
<h3 id="NIO（No-Blocking-IO）"><a href="#NIO（No-Blocking-IO）" class="headerlink" title="NIO（No-Blocking IO）"></a>NIO（No-Blocking IO）</h3><p>在BIO中，调用read，如果发现没有数据到达，就会Block；</p>
<p>在NIO中，如果没有数据到达，会立刻返回-1，并将errno设置EAGAIN/EWOULDBLOCK。表示等一下在进行尝试，加入轮询队列</p>
<h5 id="NIO新问题"><a href="#NIO新问题" class="headerlink" title="NIO新问题"></a>NIO新问题</h5><ol>
<li>在轮询中会频繁切换线程，导致Context Switch。每次切换都会在用户态和核心态切换一次。</li>
<li>停顿时间设置，不合理的停顿时间会影响系统性能。</li>
</ol>
<h5 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h5><p><img src="640" alt="img"></p>
<p>多个socket共用线程，监听每个socket的事件，使用select进行选择</p>
<p><img src="165327_uH4K_2243330.png" alt="img"></p>
<ol>
<li><p>得到Channel</p>
</li>
<li><p>申请Buffer</p>
</li>
<li><p>建立Channel和Buffer的读/写关系</p>
</li>
<li><p>关闭</p>
</li>
</ol>
<h6 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h6><ul>
<li><p>Buffers（缓冲区）</p>
</li>
<li><p>Selectors（选择器）</p>
</li>
<li>Channels（通道）</li>
</ul>
<p>一个Channel可以和文件或者网络Socket对应 。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java学习/JVM内存结构VSJava内存模型VSJava对象模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java学习/JVM内存结构VSJava内存模型VSJava对象模型/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>由java虚拟机规范定义。描述的是java程序执行过程中，由JVM管理的不同内存区域。各个区域都有各自的作用。</p>
<p><img src="1534254508736.png" alt="1534254508736"></p>
<h3 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h3><p>在java内存结构中，堆和方法区是属于所有线程共享的数据区域，这也就是“Java线程间通过内存共享进行通信”。</p>
<p>在JMM中把多个线程共享的内存区域称为<strong>主内存</strong>，并在多并发编程中多个线程都维护了一个自己的本地内存（这是抽象的概念）其中保存的是主内存中的数据拷贝。</p>
<p>而JMM的主要目的是控制本地内存和主内存之间的数据交互的。</p>
<h3 id="Java对象模型"><a href="#Java对象模型" class="headerlink" title="Java对象模型"></a>Java对象模型</h3><p>关于Java对象自身的存储模型称为Java对象模型。</p>
<p>在HotSpot虚拟机中，设计了一个OOP-Klass Model。OOP（ordinary object pointer）普通对象指针，Klass描述对象实例的具体类型。</p>
<p>每一个Java类，在加载的时候，会自动创建一个instanceKlass，保存在方法区，以在JVM层表示Java类。</p>
<p>在代码中new一个java对象时，JVM创建一个instanceOopDesc对象，这个对象包含了对象头和实例数据。</p>
<p><img src="1534257186210.png" alt="1534257186210"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>JVM内存结构，和java虚拟机的运行时区域有关。</li>
<li>Java内存模型，和并发编程有关。</li>
<li>Java对象模型， 和Java对象在虚拟机中表现形式有关。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">李楚豪的博客</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">85</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李楚豪的博客</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
