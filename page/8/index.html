<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/Netty/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/Netty/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:22+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://mp.weixin.qq.com/s?__biz=MzIxNjA5MTM2MA==&amp;mid=2652435160&amp;idx=1&amp;sn=08a3757772e2edcedbd207d04ae21e22&amp;chksm=8c620d57bb158441aa2b81587b67ba446ae3b17599b213f2d985914584d98aee3bac7844ab04&amp;scene=0&amp;xtrack=1#rd" target="_blank" rel="noopener">原文</a></p>
<h3 id="JDK原生API问题"><a href="#JDK原生API问题" class="headerlink" title="JDK原生API问题"></a>JDK原生API问题</h3><p>JDK原生也有一套网络应用程序API，但是存在一系列问题，主要如下：</p>
<ul>
<li>NIO的类库和API繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等</li>
<li>需要具备其它的额外技能做铺垫，例如熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序</li>
<li>可靠性能力补齐，开发工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等，NIO编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大</li>
<li>JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%。官方声称在JDK1.6版本的update18修复了该问题，但是直到JDK1.7版本该问题仍旧存在，只不过该bug发生概率降低了一些而已，它并没有被根本解决</li>
</ul>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</span><br><span class="line"></span><br><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br><span class="line"></span><br><span class="line">int epfd = epoll_create(10);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p><img src="/641.png" alt="img"></p>
<p>在I/O复用模型中，会用到select，这个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数.</p>
<h4 id="Netty使用的IO模型"><a href="#Netty使用的IO模型" class="headerlink" title="Netty使用的IO模型"></a>Netty使用的IO模型</h4><p><img src="/642.png" alt="img"></p>
<h3 id="Reactor线程模型"><a href="#Reactor线程模型" class="headerlink" title="Reactor线程模型"></a>Reactor线程模型</h3><p>Reactor是反应堆的意思，Reactor模型，是指通过一个或多个输入同时传递给服务处理器的服务请求的<strong>事件驱动处理模式</strong>。</p>
<p>Reactor指的是服务器处理请求时，将所有请求用Reactor(反应堆)接收，然后将请求分发到handlers（处理器）来进行处理。</p>
<p>另外Netty中使用的是<strong>主从Reactor</strong>。</p>
<p><strong>主从Reactor</strong>多线程模型有多个Reactor：MainReactor和SubReactor：</p>
<ul>
<li>MainReactor负责客户端的连接请求，并将请求转交给SubReactor</li>
<li>SubReactor负责相应通道的IO读写请求</li>
<li>非IO请求（具体逻辑处理）的任务则会直接写入队列，等待worker threads进行处理</li>
</ul>
<p><img src="/1.png" alt="img"></p>
<p><strong>事件驱动模型</strong></p>
<p>发生事件，主线程把事件放入事件队列，在另外线程不断循环消费事件列表中的事件，调用事件对应的处理逻辑处理事件。事件驱动方式也被称为消息通知方式，其实是设计模式中<strong>观察者模式</strong>的思路。</p>
<p>主要包括4个基本组件：</p>
<ul>
<li>事件队列（event queue）：接收事件的入口，存储待处理事件</li>
<li>分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元</li>
<li>事件通道（event channel）：分发器与处理器之间的联系渠道</li>
<li>事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作</li>
</ul>
<p><img src="/2.png" alt="img"></p>
<h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><ul>
<li>传输服务<br>支持BIO和NIO</li>
<li>容器集成<br>支持OSGI、JBossMC、Spring、Guice容器</li>
<li>协议支持<br>HTTP、Protobuf、二进制、文本、WebSocket等一系列常见协议都支持。<br>还支持通过实行编码解码逻辑来实现自定义协议</li>
<li>Core核心<br>可扩展事件模型、通用通信API、支持零拷贝的ByteBuf缓冲对象</li>
</ul>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><h4 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a><strong>Bootstrap、ServerBootstrap</strong></h4><p>Bootstrap意思是引导，一个Netty应用通常由一个Bootstrap开始，主要作用是配置整个Netty程序，串联各个组件，Netty中Bootstrap类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类。</p>
<p>####<strong>Future、ChannelFuture</strong></p>
<p>正如前面介绍，在Netty中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理，但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future和ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件。</p>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a><strong>Channel</strong></h4><p>Netty网络通信的组件，能够用于执行网络I/O操作。<br>Channel为用户提供：</p>
<ul>
<li><p>当前网络连接的通道的状态（例如是否打开？是否已连接？）</p>
</li>
<li><p>网络连接的配置参数 （例如接收缓冲区大小）</p>
</li>
<li><p>提供异步的网络I/O操作(如建立连接，读写，绑定端口)，异步调用意味着任何I / O调用都将立即返回，并且不保证在调用结束时所请求的I / O操作已完成。调用立即返回一个ChannelFuture实例，通过注册监听器到ChannelFuture上，可以I / O操作成功、失败或取消时回调通知调用方。</p>
</li>
<li><p>支持关联I/O操作与对应的处理程序</p>
<p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，下面是一些常用的 Channel 类型</p>
</li>
<li><p>NioSocketChannel，异步的客户端 TCP Socket 连接</p>
</li>
<li><p>NioServerSocketChannel，异步的服务器端 TCP Socket 连接</p>
</li>
<li><p>NioDatagramChannel，异步的 UDP 连接</p>
</li>
<li><p>NioSctpChannel，异步的客户端 Sctp 连接</p>
</li>
<li><p>NioSctpServerChannel，异步的 Sctp 服务器端连接</p>
</li>
</ul>
<p>这些通道涵盖了 UDP 和 TCP网络 IO以及文件 IO.</p>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a><strong>Selector</strong></h4><p>Netty基于Selector对象实现I/O多路复用，通过 Selector, 一个线程可以监听多个连接的Channel事件, 当向一个Selector中注册Channel 后，Selector 内部的机制就可以自动不断地查询(select) 这些注册的Channel是否有已就绪的I/O事件(例如可读, 可写, 网络连接完成等)，这样程序就可以很简单地使用一个线程高效地管理多个 Channel 。</p>
<h4 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a><strong>NioEventLoop</strong></h4><p>NioEventLoop中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用NioEventLoop的run方法，执行I/O任务和非I/O任务：</p>
<ul>
<li>I/O任务<br>即selectionKey中ready的事件，如accept、connect、read、write等，由processSelectedKeys方法触发。</li>
<li>非IO任务<br>添加到taskQueue中的任务，如register0、bind0等任务，由runAllTasks方法触发。</li>
</ul>
<p>两种任务的执行时间比由变量ioRatio控制，默认为50，则表示允许非IO任务执行的时间与IO任务的执行时间相等。</p>
<h4 id="NioEventLoopGroup"><a href="#NioEventLoopGroup" class="headerlink" title="NioEventLoopGroup"></a><strong>NioEventLoopGroup</strong></h4><p>NioEventLoopGroup，主要管理eventLoop的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个Channel上的事件，而一个Channel只对应于一个线程。</p>
<h4 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a><strong>ChannelHandler</strong></h4><p>ChannelHandler是一个接口，处理I / O事件或拦截I / O操作，并将其转发到其ChannelPipeline(业务处理链)中的下一个处理程序。</p>
<p>ChannelHandler本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类：</p>
<ul>
<li>ChannelInboundHandler用于处理入站I / O事件</li>
<li>ChannelOutboundHandler用于处理出站I / O操作</li>
</ul>
<p>或者使用以下适配器类：</p>
<ul>
<li><p>ChannelInboundHandlerAdapter用于处理入站I / O事件</p>
</li>
<li><p>ChannelOutboundHandlerAdapter用于处理出站I / O操作</p>
</li>
<li><p>ChannelDuplexHandler用于处理入站和出站事件</p>
</li>
</ul>
<h4 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a><strong>ChannelHandlerContext</strong></h4><p>保存Channel相关的所有上下文信息，同时关联一个ChannelHandler对象</p>
<h4 id="ChannelPipline"><a href="#ChannelPipline" class="headerlink" title="ChannelPipline"></a><strong>ChannelPipline</strong></h4><p>保存ChannelHandler的List，用于处理或拦截Channel的入站事件和出站操作。 ChannelPipeline实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及Channel中各个的ChannelHandler如何相互交互。</p>
<p>下图引用Netty的Javadoc4.1中ChannelPipline的说明，描述了ChannelPipeline中ChannelHandler通常如何处理I/O事件。 I/O事件由ChannelInboundHandler或ChannelOutboundHandler处理，并通过调用ChannelHandlerContext中定义的事件传播方法（例如ChannelHandlerContext.fireChannelRead（Object）和ChannelOutboundInvoker.write（Object））转发到其最近的处理程序。</p>
<p><img src="/3.png" alt="img"></p>
<p>入站事件由自下而上方向的入站处理程序处理，如图左侧所示。 入站Handler处理程序通常处理由图底部的I / O线程生成的入站数据。 通常通过实际输入操作（例如SocketChannel.read（ByteBuffer））从远程读取入站数据。</p>
<p>出站事件由上下方向处理，如图右侧所示。 出站Handler处理程序通常会生成或转换出站传输，例如write请求。 I/O线程通常执行实际的输出操作，例如SocketChannel.write（ByteBuffer）。</p>
<p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应, 它们的组成关系如下:</p>
<p><img src="/4.png" alt="img"></p>
<p>一个 Channel 包含了一个 ChannelPipeline, 而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表, 并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。入站事件和出站事件在一个双向链表中，入站事件会从链表head往后传递到最后一个入站的handler，出站事件会从链表tail往前传递到最前一个出站的handler，两种类型的handler互不干扰。</p>
<h3 id="服务器启动代码"><a href="#服务器启动代码" class="headerlink" title="服务器启动代码"></a>服务器启动代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       // 创建mainReactor</span><br><span class="line">       NioEventLoopGroup boosGroup = new NioEventLoopGroup();</span><br><span class="line">       // 创建工作线程组</span><br><span class="line">       NioEventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">       final ServerBootstrap serverBootstrap = new ServerBootstrap();</span><br><span class="line">       serverBootstrap </span><br><span class="line">                // 组装NioEventLoopGroup </span><br><span class="line">               .group(boosGroup, workerGroup)</span><br><span class="line">                // 设置channel类型为NIO类型</span><br><span class="line">               .channel(NioServerSocketChannel.class)</span><br><span class="line">               // 设置连接配置参数</span><br><span class="line">               .option(ChannelOption.SO_BACKLOG, 1024)</span><br><span class="line">               .childOption(ChannelOption.SO_KEEPALIVE, true)</span><br><span class="line">               .childOption(ChannelOption.TCP_NODELAY, true)</span><br><span class="line">               // 配置入站、出站事件handler</span><br><span class="line">               .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   protected void initChannel(NioSocketChannel ch) &#123;</span><br><span class="line">                       // 配置入站、出站事件channel</span><br><span class="line">                       ch.pipeline().addLast(...);</span><br><span class="line">                       ch.pipeline().addLast(...);</span><br><span class="line">                   &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">       // 绑定端口</span><br><span class="line">       int port = 8080;</span><br><span class="line">       serverBootstrap.bind(port).addListener(future -&gt; &#123;</span><br><span class="line">           if (future.isSuccess()) &#123;</span><br><span class="line">               System.out.println(new Date() + &quot;: 端口[&quot; + port + &quot;]绑定成功!&quot;);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               System.err.println(&quot;端口[&quot; + port + &quot;]绑定失败!&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工作架构"><a href="#工作架构" class="headerlink" title="工作架构"></a>工作架构</h3><p><img src="/5.png" alt="img"></p>
<p>server端包含1个Boss NioEventLoopGroup和1个Worker NioEventLoopGroup，NioEventLoopGroup相当于1个事件循环组，这个组里包含多个事件循环NioEventLoop，每个NioEventLoop包含1个selector和1个事件循环线程。</p>
<p>每个Boss NioEventLoop循环执行的任务包含3步：</p>
<ol>
<li>轮询accept事件</li>
<li>处理accept I/O事件，与Client建立连接，生成NioSocketChannel，并将NioSocketChannel注册到某个Worker NioEventLoop的Selector上</li>
<li>处理任务队列中的任务，runAllTasks。任务队列中的任务包括用户调用eventloop.execute或schedule执行的任务，或者其它线程提交到该eventloop的任务。</li>
</ol>
<p>每个Worker NioEventLoop循环执行的任务包含3步：</p>
<ol>
<li>轮询read、write事件；</li>
<li>处I/O事件，即read、write事件，在NioSocketChannel可读、可写事件发生时进行处理</li>
<li>处理任务队列中的任务，runAllTasks。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/Mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/Mybatis/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:22+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">mybatis部分文档</a></p>
<h3 id="Mybatis的导入"><a href="#Mybatis的导入" class="headerlink" title="Mybatis的导入"></a>Mybatis的导入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">http://central.maven.org/maven2/org/mybatis/mybatis/3.4.6/mybatis-3.4.6.jar</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;x.x.x&lt;/version&gt;</span><br><span class="line">5&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line"> &lt;!DOCTYPE configuration</span><br><span class="line">         PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"> &lt;configuration&gt;</span><br><span class="line">    &lt;!--properties用于定义一些属性变量，以便在配置文件中调用--&gt;</span><br><span class="line">     &lt;properties&gt;</span><br><span class="line">         &lt;!--定义一个变量为driver的属性，在下面就可以用$&#123;driver&#125;来获得其属性值--&gt;</span><br><span class="line">         &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;</span><br><span class="line">         &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://rm-wz9b714vle01fg8ijmo.mysql.rds.aliyuncs.com/change_hair&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;!--定义不同环境下的配置，便于区分生产、测试等环节的配置--&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">       &lt;!--定义一个环境下的配置--&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;Blackeye100&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;!--用于设置mapper文件的引入--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;!--resource方式引入mapper文件--&gt;</span><br><span class="line">        &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<h3 id="常用的settings"><a href="#常用的settings" class="headerlink" title="常用的settings"></a>常用的settings</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">  #设置配置文件中的所有映射器已经配置的任何缓存，默认false。</span><br><span class="line">  &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  #延迟加载的全局开关。当开启时，所有关联对象都会延迟加载，默认为false</span><br><span class="line">  &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  #是否允许单一语句返回多结果集，默认为true</span><br><span class="line">  &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  #是否使用列标签代替列名，默认为true</span><br><span class="line">  &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">  #是否允许JDBC支持自动生成主键，默认为false</span><br><span class="line">  &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">  #指定 MyBatis 应如何自动映射列到字段或属性</span><br><span class="line">  &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt;</span><br><span class="line">  #指定发现自动映射目标未知列（或者未知属性类型）的行为，默认NONE</span><br><span class="line">  #NONE: 不做任何反应</span><br><span class="line">  #WARNING: 输出提醒日志</span><br><span class="line">  #FAILING: 映射失败 (抛出 SqlSessionException)</span><br><span class="line">  &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt;</span><br><span class="line">  #配置默认的执行器。默认为SIMPLE</span><br><span class="line">  #SIMPLE 就是普通的执行器；</span><br><span class="line">  #REUSE 执行器会重用预处理语句； </span><br><span class="line">  #BATCH 执行器将重用语句并执行批量更新</span><br><span class="line">  &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt;</span><br><span class="line">  #设置超时时间，它决定驱动等待数据库响应的秒数。 </span><br><span class="line">  &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt;</span><br><span class="line">  #为驱动的结果集获取数量（fetchSize）设置一个提示值  </span><br><span class="line">  &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt;</span><br><span class="line">  #是否允许在嵌套语句中使用分页。如果允许使用则设置为false。</span><br><span class="line">  &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">  #是否开启自动驼峰命名规则（camel case）映射，默认为false</span><br><span class="line">  &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static static void main(String[] args)&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">        InputStream in = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);</span><br><span class="line">        SqlSession s = sqlSessionFactory.openSession();</span><br><span class="line">        </span><br><span class="line">        UserMapper mapper = s.getMapper(UserMapper.class);</span><br><span class="line">        </span><br><span class="line">       User user = mapper,getUserByName(&quot;name&quot;);</span><br><span class="line">       </span><br><span class="line">       if(user != null)&#123;</span><br><span class="line">           system.out.print(user.getname());</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/Maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/Maven/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:22+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><a href="http://tengj.top/2018/01/01/maven/" target="_blank" rel="noopener">Maven</a></h1><p><a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">官网</a></p>
<h3 id="常用命令说明"><a href="#常用命令说明" class="headerlink" title="常用命令说明"></a>常用命令说明</h3><p><strong>mvn clean：</strong>表示运行清理操作（会默认把target文件夹中的数据清理）。<br><strong>mvn clean compile：</strong>表示先运行清理之后运行编译，会将代码编译到target文件夹中。<br><strong>mvn clean test：</strong>运行清理和测试。<br><strong>mvn clean package：</strong>运行清理和打包。<br><strong>mvn clean install：</strong>运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用。<br><strong>mvn clean deploy：</strong>运行清理和发布（发布到私服上面）。</p>
<h3 id="常用POM属性"><a href="#常用POM属性" class="headerlink" title="常用POM属性"></a>常用POM属性</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$&#123;project.build.sourceDirectory&#125;:项目的主源码目录，默认为src/main/java/. </span><br><span class="line">$&#123;project.build.testSourceDirectory&#125;:项目的测试源码目录，默认为/src/test/java/.</span><br><span class="line">$&#123;project.build.directory&#125;:项目构建输出目录，默认为target/.</span><br><span class="line">$&#123;project.build.outputDirectory&#125;:项目主代码编译输出目录，默认为target/classes/.</span><br><span class="line">$&#123;project.build.testOutputDirectory&#125;:项目测试代码编译输出目录，默认为target/testclasses/.</span><br><span class="line">$&#123;project.groupId&#125;:项目的groupId.</span><br><span class="line">$&#123;project.artifactId&#125;:项目的artifactId.</span><br><span class="line">$&#123;project.version&#125;:项目的version,于$&#123;version&#125;等价</span><br><span class="line">$&#123;project.build.finalName&#125;:项目打包输出文件的名称，默认为$&#123;project.artifactId&#125;$&#123;project.version&#125;.</span><br></pre></td></tr></table></figure>
<h3 id="POM-XML头部"><a href="#POM-XML头部" class="headerlink" title="POM.XML头部"></a>POM.XML头部</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.tengj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springBootDemo1&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;springBootDemo1&lt;/name&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>代码的第一行是XML头，指定了该xml文档的版本和编码方式。<br>project是所有pom.xml的根元素，它还声明了一些POM相关的命名空间及xsd元素。<br>根元素下的第一个子元素modelVersion指定了当前的POM模型的版本，对于Maven3来说，它只能是4.0.0<br>代码中最重要是包含了groupId,artifactId和version了。这三个元素定义了一个项目基本的坐标，在Maven的世界，任何的jar、pom或者jar都是以基于这些基本的坐标进行区分的。</p>
<p>groupId定义了项目属于哪个组，随意命名，比如谷歌公司的myapp项目，就取名为 com.google.myapp</p>
<p>artifactId定义了当前Maven项目在组中唯一的ID,比如定义hello-world。</p>
<p>version指定了项目当前的版本0.0.1-SNAPSHOT,SNAPSHOT意为快照，说明该项目还处于开发中，是不稳定的。</p>
<p>name元素生命了一个对于用户更为友好的项目名称，虽然这不是必须的，但还是推荐为每个POM声明name,以方便信息交流</p>
<h3 id="依赖的配置（dependency）"><a href="#依赖的配置（dependency）" class="headerlink" title="依赖的配置（dependency）"></a>依赖的配置（dependency）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;</span><br><span class="line">...</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;实际项目&lt;/groupId&gt;</span><br><span class="line">　　　　 &lt;artifactId&gt;模块&lt;/artifactId&gt;</span><br><span class="line">　　　　 &lt;version&gt;版本&lt;/version&gt;</span><br><span class="line">　　　　 &lt;type&gt;依赖类型&lt;/type&gt;</span><br><span class="line">　　　　 &lt;scope&gt;依赖范围&lt;/scope&gt;</span><br><span class="line">　　　　 &lt;optional&gt;依赖是否可选&lt;/optional&gt;</span><br><span class="line">　　　　 &lt;!—主要用于排除传递性依赖--&gt;</span><br><span class="line">　　　　 &lt;exclusions&gt;</span><br><span class="line">　　　　     &lt;exclusion&gt;</span><br><span class="line">　　　　　　　    &lt;groupId&gt;…&lt;/groupId&gt;</span><br><span class="line">　　　　　　　　　 &lt;artifactId&gt;…&lt;/artifactId&gt;</span><br><span class="line">　　　　　　　&lt;/exclusion&gt;</span><br><span class="line">　　　　 &lt;/exclusions&gt;</span><br><span class="line">　　&lt;/dependency&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<p>根元素project下的dependencies可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有：</p>
<ul>
<li><strong>grounpId、artifactId和version</strong>:以来的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。</li>
<li><strong>type</strong>:依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar</li>
<li><strong>scope</strong>:依赖的范围</li>
<li><strong>optional</strong>:标记依赖是否可选</li>
<li><strong>exclusions</strong>:用来排除传递性依赖</li>
</ul>
<h3 id="依赖范围（scope）"><a href="#依赖范围（scope）" class="headerlink" title="依赖范围（scope）"></a>依赖范围（scope）</h3><p>依赖范围就是用来控制依赖和三种classpath(编译classpath，测试classpath、运行classpath)的关系，Maven有如下几种依赖范围：</p>
<ul>
<li><strong>compile:</strong>编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-code,在编译、测试和运行的时候都需要使用该依赖。</li>
<li><strong>test:</strong> 测试依赖范围。使用次依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。</li>
<li><strong>provided:</strong>已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要Maven重复地引入一遍。</li>
<li><strong>runtime:</strong>运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</li>
<li><strong>system:</strong>系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致，但是，使用system范围的依赖时必须通过systemPath元素显示地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能构成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量，如：</li>
<li><strong>import:</strong>导入依赖范围。该依赖范围不会对三种classpath产生实际的影响。</li>
</ul>
<p><img src="1536307787152.png" alt="1536307787152"></p>
<h3 id="传递性依赖"><a href="#传递性依赖" class="headerlink" title="传递性依赖"></a>传递性依赖</h3><p>比如一个account-email项目为例，account-email有一个compile范围的spring-code依赖，spring-code有一个compile范围的commons-logging依赖，那么commons-logging就会成为account-email的compile的范围依赖，commons-logging是account-email的一个传递性依赖</p>
<p><img src="1536308873895.png" alt="1536308873895"></p>
<p>有了传递性依赖机制，在使用Spring Framework的时候就不用去考虑它依赖了什么，也不用担心引入多余的依赖。Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。</p>
<h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>假设A依赖于B,B依赖于C，我们说A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖。第一直接依赖和第二直接依赖的范围决定了传递性依赖的范围，如下图所示，最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间的交叉单元格则表示传递依赖范围。</p>
<p><img src="1536308956241.png" alt="1536308956241"></p>
<p>从上图中，我们可以发现这样的规律：</p>
<ul>
<li>当第二直接依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致；</li>
<li>当第二直接依赖的范围是test的时候，依赖不会得以传递；</li>
<li>当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，切传递依赖的范围同样为provided;</li>
<li>当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile列外，此时传递性依赖范围为runtime.</li>
</ul>
<h3 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h3><p>当依赖发生冲突时会根据以下两条规则进行调解</p>
<ol>
<li>路径最近者优先<br>比如项目有A有这样的依赖关系：A-&gt;B-&gt;C-&gt;X(1.0)、A-&gt;D-&gt;X(2.0),X是A的传递性依赖，但是两条依赖路径上有两个版本的X，所以根据第一原则，A-&gt;D-&gt;X(2.0)路径短，所以X(2.0)会被解析使用</li>
<li>第一声明者优先<br>如果路径都一样长的话，第一原则就不行了，比如 A-&gt;B-&gt;Y(1.0)、A-&gt;C-&gt;Y(2.0),Y(1.0)和Y(2.0)的路径一样，所以这时候根据第二原则，先声明的被解析。</li>
</ol>
<h3 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h3><p><img src="1536309191615.png" alt="1536309191615"></p>
<p>如图，项目中A依赖B，B依赖于X和Y，如果所有这三个的范围都是compile的话，那么X和Y就是A的compile范围的传递性依赖，但是如果我想X,Y不作为A的传递性依赖，不给他用的话。就需要下面提到的配置可选依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;  </span><br><span class="line">    ………</span><br><span class="line">    &lt;dependencies&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;5.1.10&lt;/version&gt;  </span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;postgresql&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;postgresql&lt;/groupId&gt;  </span><br><span class="line">            &lt;version&gt;8.4-701.jdbc3&lt;/version&gt;  </span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;  </span><br><span class="line">        &lt;/dependency&gt;  </span><br><span class="line">    &lt;/dependencies&gt;  </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
<h3 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h3><p>有时候你引入的依赖中包含你不想要的依赖包，你想引入自己想要的，这时候就要用到排除依赖了，比如下图中spring-boot-starter-web自带了logback这个日志包，我想引入log4j2的，所以我先排除掉logback的依赖包，再引入想要的包就行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;exclusions&gt;</span><br><span class="line">    &lt;exclusion&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br></pre></td></tr></table></figure>
<p>这里注意：声明exclustion的时候只需要groupId和artifactId，而不需要version元素，这是因为只需要groupId和artifactId就能唯一定位依赖图中的某个依赖。</p>
<h3 id="归类依赖"><a href="#归类依赖" class="headerlink" title="归类依赖"></a>归类依赖</h3><p>有时候我们引入的很多依赖包，他们都来自同一个项目的不同模块，所以他们的版本号都一样，这时候我们可以用属性来统一管理版本号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;project&gt;  </span><br><span class="line">    ……</span><br><span class="line">    &lt;properties&gt;  </span><br><span class="line">        &lt;springframework.version&gt;1.5.6&lt;/springframework.version&gt;  </span><br><span class="line">    &lt;/properties&gt;  </span><br><span class="line">    &lt;dependencies&gt;  </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;   </span><br><span class="line">        &lt;dependency&gt;  </span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;  </span><br><span class="line">            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;  </span><br><span class="line">            &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;  </span><br><span class="line">        &lt;/dependency&gt;         </span><br><span class="line">    &lt;/dependencies&gt;  </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/JSP九大内置对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/JSP九大内置对象/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:22+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/kelin1314/archive/2011/03/03/1969578.html" target="_blank" rel="noopener">每个对象的常用方法</a></p>
<p>JSP九大内置对象分为三类：</p>
<ol>
<li>输入输出对象：out对象、response对象、request对象</li>
<li>通信控制对象：pageContext对象、session对象、application对象</li>
<li>Servlet对象：page对象、config对象</li>
<li>错误处理对象：exception对象</li>
</ol>
<p>内置对象特点：</p>
<ol>
<li>由JSP规范提供，不用编写者实例化。</li>
<li>通过Web容器实现和管理</li>
<li>所有JSP页面均可使用</li>
<li>只有在脚本元素的表达式或代码段中才可使用（&lt;%=使用内置对象%&gt;或&lt;%使用内置对象%&gt;）</li>
</ol>
<ul>
<li><p>Request(Javax.servlet.ServletRequest)它包含了有关浏览器请求的信息.通过该对象可以获得请求中的头信息、Cookie和请求参数。</p>
</li>
<li><p>Response(Javax.servlet.ServletResponse)作为JSP页面处理结果返回给用户的响应存储在该对象中。并提供了设置响应内容、响应头以及重定向的方法(如cookies,头信息等)</p>
</li>
<li><p>Out(Javax.servlet.jsp.JspWriter)用于将内容写入JSP页面实例的输出流中,提供了几个方法使你能用于向浏览器回送输出结果。</p>
</li>
<li><p>pageContext(Javax.servlet.jsp.PageContext)描述了当前JSP页面的运行环境。可以返回JSP页面的其他隐式对象及其属性的访问,另外,它还实现将控制权从当前页面传输至其他页面的方法。</p>
</li>
<li><p>Session(javax.servlet.http.HttpSession)会话对象存储有关此会话的信息,也可以将属性赋给一个会话,每个属性都有名称和值。会话对象主要用于存储和检索属性值。</p>
</li>
<li><p>Application(javax.servle.ServletContext)存储了运行JSP页面的servlet以及在同一应用程序中的任何Web组件的上下文信息。</p>
</li>
<li><p>Page(Java.lang.Object)表示当前JSP页面的servlet实例</p>
</li>
<li><p>Config(javax.servlet.ServletConfig)该对象用于存取servlet实例的初始化参数。</p>
</li>
<li><p>Exception(Javax.lang.Throwable)在某个页面抛出异常时,将转发至JSP错误页面,提供此对象是为了在JSP中处理错误。只有在错误页面中才可使用&lt;%@page isErrorPage=“true”%&gt;</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Jsp**</strong>内置对象**</th>
<th><strong>功能</strong></th>
<th><strong>主要方法</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>out</td>
<td>向客户端输出数据</td>
<td>print() println() flush() clear() isAutoFlush() getBufferSize()   close() …………</td>
</tr>
<tr>
<td>request</td>
<td>向客户端请求数据</td>
<td>getAttributeNames() getCookies() getParameter() getParameterValues() setAttribute() getServletPath() …………..</td>
</tr>
<tr>
<td>response</td>
<td>封装了jsp产生的响应,然后被发送到客户端以响应客户的请求</td>
<td>addCookie() sendRedirect() setContentType()flushBuffer() getBufferSize() getOutputStream()sendError() containsHeader()……………</td>
</tr>
<tr>
<td>application</td>
<td></td>
<td></td>
</tr>
<tr>
<td>config</td>
<td>表示Servlet的配置,当一个Servlet初始化时,容器把某些信息通过此对象传递给这个Servlet</td>
<td>getServletContext() getServletName() getInitParameter()   getInitParameterNames()……………</td>
</tr>
<tr>
<td>page</td>
<td>Jsp实现类的实例,它是jsp本身,通过这个可以对它进行访问</td>
<td>flush()………</td>
</tr>
<tr>
<td>pagecontext</td>
<td>为JSP页面包装页面的上下文。管理对属于JSP中特殊可见部分中己经命名对象的该问</td>
<td>forward() getAttribute() getException() getRequest() getResponse()   getServletConfig()getSession() getServletContext() setAttribute()removeAttribute() findAttribute() ……………</td>
</tr>
<tr>
<td>session</td>
<td>用来保存每个用户的信息,以便跟踪每个用户的操作状态</td>
<td>getAttribute() getId()   getAttributeNames() getCreateTime() getMaxInactiveInterval()invalidate() isNew()</td>
</tr>
<tr>
<td>exception</td>
<td>反映运行的异常</td>
<td>getMessage()…………</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/JPA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/JPA/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:22+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/index.html" target="_blank" rel="noopener">教程</a></p>
<h3 id="JPA和Hibernate的关系"><a href="#JPA和Hibernate的关系" class="headerlink" title="JPA和Hibernate的关系"></a>JPA和Hibernate的关系</h3><p>JPA 是 hibernate 的一个抽象（就像JDBC和JDBC驱动的关系）：</p>
<ul>
<li>JPA 是规范：JPA 本质上就是一种  ORM 规范，不是ORM 框架 —— 因为 JPA 并未提供 ORM 实现，它只是制订了一些规范，提供了一些编程的 API 接口，但具体实现则由 ORM 厂商提供实现</li>
<li>Hibernate 是实现：Hibernate 除了作为 ORM 框架之外，它也是一种 JPA 实现</li>
</ul>
<p>从功能上来说， JPA 是 Hibernate 功能的一个子集</p>
<h3 id="JPA-包括-3方面的技术"><a href="#JPA-包括-3方面的技术" class="headerlink" title="JPA 包括 3方面的技术"></a>JPA 包括 3方面的技术</h3><ul>
<li>ORM  映射元数据：JPA 支持 XML 和  JDK 5.0 注解两种元数据的形式，元数据描述对象和表之间的映射关系，框架据此将实体对象持久化到数据库表中。  </li>
<li>JPA 的 API：用来操作实体对象，执行CRUD操作，框架在后台完成所有的事情，开发者从繁琐的 JDBC和 SQL代码中解脱出来。  </li>
<li>查询语言（JPQL）：这是持久化操作中很重要的一个方面，通过面向对象而非面向数据库的查询语言查询数据，避免程序和具体的  SQL 紧密耦合。</li>
</ul>
<h3 id="JPA-基本注解"><a href="#JPA-基本注解" class="headerlink" title="JPA 基本注解"></a>JPA 基本注解</h3><p>JPA 基本注解:@Entity, @Table, @Id, @GeneratedValue, @Column, @Basic，@Transient, @Temporal, 用 table 来生成主键详解</p>
<ol>
<li>@Entity<pre><code>@Entity 标注用于实体类声明语句之前，**指出该Java 类为实体类，将映射到指定的数据库表**。如声明一个实体类 Customer，它将映射到数据库中的 customer 表上。
</code></pre></li>
<li>@Table<pre><code>当**实体类与其映射的数据库表名不同名**时需要使用 @Table 标注说明，该标注与 @Entity 标注并列使用，置于实体类声明语句之前，可写于单独语句行，也可与声明语句同行。
@Table 标注的**常用选项是 name**，用于指明数据库的表名
@Table标注还有一个两个选项 catalog 和 schema 用于设置表所属的数据库目录或模式，通常为数据库名。uniqueConstraints 选项用于设置约束条件，通常不须设置。
</code></pre></li>
<li>@Id<pre><code>@Id 标注用于声明一个实体类的属性映射为数据库的**主键列**。该属性通常置于属性声明语句之前，可与声明语句同行，也可写在单独行上。
@Id标注也可置于属性的**getter方法之前**。
</code></pre></li>
<li>@GeneratedValue<pre><code>@GeneratedValue  用于标注**主键的生成策略**，通过 **strategy 属性指定**。默认情况下，JPA 自动选择一个最适合底层数据库的主键生成策略：SqlServer 对应 identity， MySQL 对应 auto increment。
</code></pre>在 javax.persistence.GenerationType 中定义了以下几种可供选择的策略：<ul>
<li>IDENTITY：采用数据库 ID自增长的方式来自增主键字段，Oracle 不支持这种方式；</li>
<li>AUTO： JPA自动选择合适的策略，是<strong>默认选项</strong>；</li>
<li>SEQUENCE：通过序列产生主键，通过 @SequenceGenerator 注解指定序列名，MySql 不支持这种方式</li>
<li>TABLE：通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。</li>
</ul>
</li>
<li>@Basic<pre><code>@Basic 表示一个**简单的属性到数据库表的字段的映射**,**对于没有任何标注的 getXxxx() 方法,默认即为@Basic**
fetch: 表示该属性的读取策略,有 EAGER 和 LAZY 两种,分别表示主支抓取和延迟加载,默认为 EAGER.
**optional:表示该属性是否允许为null, 默认为true** 
</code></pre></li>
<li>@Column<pre><code>当实体的**属性与其映射的数据库表的列不同名**时需要使用@Column 标注说明，该属性通常置于实体的属性声明语句之前，还可与 @Id 标注一起使用。
@Column 标注的常用属性是 name，用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，如：unique 、nullable、length等。
@Column 标注的 columnDefinition 属性: 表示该**字段在数据库中的实际类型**.通常 ORM 框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是DATE,TIME还是TIMESTAMP.此外,**String的默认映射类型为VARCHAR**, 如果要将 String 类型映射到特定数据库的 BLOB 或TEXT 字段类型.
@Column标注也可置于属性的getter方法之前
</code></pre></li>
<li>@Transient<pre><code>表示该**属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性.**
如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic
</code></pre></li>
<li>@Temporal<pre><code>在核心的 Java API 中并没有定义 Date 类型的精度(temporal precision).  而在数据库中,表示 Date 类型的数据有 DATE, TIME, 和 TIMESTAMP 三种精度(即单纯的日期,时间,或者两者 兼备).**在进行属性映射时可使用@Temporal注解来调整精度.**
</code></pre></li>
<li>用 table 来生成主键详解<pre><code>将**当前主键的值单独保存到一个数据库的表**中，主键的值每次都是从指定的表中查询来获得。这种方法生成主键的策略可以适用于任何数据库，不必担心不同数据库不兼容造成的问题。
</code></pre></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 注解@Entity映射的表名和类名一样</span><br><span class="line"> * 注解@Table：当实体类与其映射的数据库表名不同名时使用。其中name，用于指明数据库的表名 </span><br><span class="line"> */</span><br><span class="line">@Table(name=&quot;JPA_CUTOMERS&quot;)</span><br><span class="line">@Entity</span><br><span class="line">public class Customer &#123;</span><br><span class="line">	private Integer id;</span><br><span class="line">	private String lastName;</span><br><span class="line">	private String email;</span><br><span class="line">	private int age;</span><br><span class="line">	private Date createdTime;</span><br><span class="line">	private Date birth;</span><br><span class="line"> </span><br><span class="line">	public Customer() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">//用 table 来生成主键详解（用的少）:</span><br><span class="line">//将当前主键的值单独保存到一个数据库的表中，主键的值每次都是从指定的表中查询来获得</span><br><span class="line">//这种方法生成主键的策略可以适用于任何数据库，不必担心不同数据库不兼容造成的问题</span><br><span class="line">/*	@TableGenerator(name=&quot;ID_GENERATOR&quot;, --name 属性表示该主键生成的名称，它被引用在@GeneratedValue中设置的generator 值中(即这两个名字要一样）</span><br><span class="line">			table=&quot;jpa_id_generators&quot;,   --table 属性表示表生成策略所持久化的表名</span><br><span class="line">			pkColumnName=&quot;PK_NAME&quot;,      --pkColumnName 属性的值表示在持久化表中，该主键生成策略所对应键值的名称</span><br><span class="line">			pkColumnValue=&quot;CUSTOMER_ID&quot;, --pkColumnValue 属性的值表示在持久化表中，该生成策略所对应的主键（跟pkColumnName属性可以确定唯一的一行，该行有很多列）</span><br><span class="line">			valueColumnName=&quot;PK_VALUE&quot;,  --valueColumnName 属性的值表示在持久化表中，该主键当前所生成的值，它的值将会随着每次创建累加，（再加这个属性能确定唯一的那个点）</span><br><span class="line">			allocationSize=100)          --allocationSize 表示每次主键值增加的大小, 默认值为 50</span><br><span class="line">	@GeneratedValue(strategy=GenerationType.TABLE,generator=&quot;ID_GENERATOR&quot;)*/</span><br><span class="line">	@GeneratedValue(strategy=GenerationType.AUTO)</span><br><span class="line">	@Id</span><br><span class="line">	public Integer getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(Integer id) &#123;</span><br><span class="line">		this.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/**</span><br><span class="line">	 * 注解@Column 当实体的属性与其映射的数据库表的列不同名时需要使用</span><br><span class="line">	 * nullable=false不能为空</span><br><span class="line">	 */</span><br><span class="line">	@Column(name=&quot;LAST_NAME&quot;,length=50,nullable=false)</span><br><span class="line">	public String getLastName() &#123;</span><br><span class="line">		return lastName;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setLastName(String lastName) &#123;</span><br><span class="line">		this.lastName = lastName;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//如果 列名跟字段一样如列名是email，则可以不用写，相关加了@Basic，但字段的属性都是默认的</span><br><span class="line">//	@Basic</span><br><span class="line">	public String getEmail() &#123;</span><br><span class="line">		return email;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setEmail(String email) &#123;</span><br><span class="line">		this.email = email;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	public int getAge() &#123;</span><br><span class="line">		return age;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setAge(int age) &#123;</span><br><span class="line">		this.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//---------------------------------------------------------------</span><br><span class="line">	//注解@Temporal 调整时间精度 2015-11-11 10:11:11</span><br><span class="line">	@Temporal(TemporalType.TIMESTAMP)</span><br><span class="line">	public Date getCreatedTime() &#123;</span><br><span class="line">		return createdTime;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setCreatedTime(Date createdTime) &#123;</span><br><span class="line">		this.createdTime = createdTime;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//2015-11-11</span><br><span class="line">	@Temporal(TemporalType.DATE)</span><br><span class="line">	public Date getBirth() &#123;</span><br><span class="line">		return birth;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setBirth(Date birth) &#123;</span><br><span class="line">		this.birth = birth;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//工具方法. 不需要映射为数据表的一列. 如果没有加@Transient，则会出错，因为没有set方法</span><br><span class="line">	@Transient</span><br><span class="line">	public String getInfo()&#123;</span><br><span class="line">		return &quot;lastName: &quot; + lastName + &quot;, email: &quot; + email;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面总结一下使用 Spring Data JPA 进行持久层开发大致需要的三个步骤：</p>
<ol>
<li>声明持久层的接口，该接口继承 Repository，Repository 是一个标记型接口，它不包含任何方法，当然如果有需要，Spring Data 也提供了若干 Repository 子接口，其中定义了一些常用的增删改查，以及分页相关的方法。</li>
<li>在接口中声明需要的业务方法。Spring Data 将根据给定的策略（具体策略稍后讲解）来为其生成实现代码。</li>
<li>在 Spring 配置文件中增加一行声明，让 Spring 为声明的接口创建代理对象。配置了 <a href="jpa:repositories" target="_blank" rel="noopener">jpa:repositories</a> 后，Spring 初始化容器时将会扫描 base-package 指定的包目录及其子目录，为继承 Repository 或其子接口的接口创建代理对象，并将代理对象注册为 Spring Bean，业务层便可以通过 Spring 自动封装的特性来直接使用该对象。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/JMS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/JMS/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:22+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java消息服务"><a href="#Java消息服务" class="headerlink" title="Java消息服务"></a><a href="https://www.cnblogs.com/chenpi/p/5559349.html" target="_blank" rel="noopener">Java消息服务</a></h1><h3 id="点对点消息传送模型"><a href="#点对点消息传送模型" class="headerlink" title="点对点消息传送模型"></a>点对点消息传送模型</h3><p>在点对点消息传送模型中，应用程序由消息队列，发送者，接收者组成。每一个消息发送给一个特殊的消息队列，该队列保存了所有发送给它的消息(除了被接收者消费掉的和过期的消息)。点对点消息模型有一些特性，如下：</p>
<ul>
<li>每个消息只有一个接收者；</li>
<li>消息发送者和接收者并没有时间依赖性；</li>
<li>当消息发送者发送消息的时候，无论接收者程序在不在运行，都能获取到消息；</li>
<li>当接收者收到消息的时候，会发送确认收到通知（acknowledgement）。</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/879896/201606/879896-20160604194640227-215496499.gif" alt="img"></p>
<h3 id="发布-订阅消息传递模型"><a href="#发布-订阅消息传递模型" class="headerlink" title="发布/订阅消息传递模型"></a>发布/订阅消息传递模型</h3><p>在发布/订阅消息模型中，发布者发布一个消息，该消息通过topic传递给所有的客户端。在这种模型中，发布者和订阅者彼此不知道对方，是匿名的且可以动态发布和订阅topic。topic主要用于保存和传递消息，且会一直保存消息直到消息被传递给客户端。发布/订阅消息模型特性如下：</p>
<ul>
<li>一个消息可以传递给多个订阅者</li>
<li>发布者和订阅者有时间依赖性，只有当客户端创建订阅后才能接受消息，且订阅者需一直保持活动状态以接收消息。</li>
<li>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</li>
</ul>
<p><img src="https://images2015.cnblogs.com/blog/879896/201606/879896-20160604232610055-1944763982.gif" alt="img"></p>
<p>JMS应用程序由如下基本模块组成：</p>
<ol>
<li>管理对象（Administered objects）：连接工厂（Connection Factories）和目的地（Destination）</li>
<li>连接对象（Connections）</li>
<li>会话（Sessions）</li>
<li>消息生产者（Message Producers）</li>
<li>消息消费者（Message Consumers）</li>
<li>消息监听者（Message Listeners）</li>
</ol>
<p><img src="https://images2015.cnblogs.com/blog/879896/201606/879896-20160604234140321-1865897064.png" alt="img"></p>
<h3 id="连接工厂（ConnectionFactory）"><a href="#连接工厂（ConnectionFactory）" class="headerlink" title="连接工厂（ConnectionFactory）"></a>连接工厂（ConnectionFactory）</h3><p>客户端使用一个连接工厂对象连接到JMS服务提供者，它创建了JMS服务提供者和客户端之间的连接。JMS客户端（如发送者或接受者）会在JNDI名字空间中搜索并获取该连接。使用该连接，客户端能够与目的地通讯，往队列或话题发送/接收消息。让我们用一个例子来理解如何发送消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueueConnectionFactory queueConnFactory = (QueueConnectionFactory) initialCtx.lookup (&quot;primaryQCF&quot;);</span><br><span class="line">Queue purchaseQueue = (Queue) initialCtx.lookup (&quot;Purchase_Queue&quot;);</span><br><span class="line">Queue returnQueue = (Queue) initialCtx.lookup (&quot;Return_Queue&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="目的地（Destination）"><a href="#目的地（Destination）" class="headerlink" title="目的地（Destination）"></a>目的地（Destination）</h3><p>目的地指明消息被发送的目的地以及客户端接收消息的来源。JMS使用两种目的地，队列和话题。如下代码指定了一个队列和话题。</p>
<p><strong>创建一个队列Session</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueueSession ses = con.createQueueSession (false, Session.AUTO_ACKNOWLEDGE);  //get the Queue object  </span><br><span class="line">Queue t = (Queue) ctx.lookup (&quot;myQueue&quot;);  //create QueueReceiver  </span><br><span class="line">QueueReceiver receiver = ses.createReceiver(t);</span><br></pre></td></tr></table></figure>
<p><strong>创建一个话题Session</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TopicSession ses = con.createTopicSession (false, Session.AUTO_ACKNOWLEDGE); // get the Topic object  </span><br><span class="line">Topic t = (Topic) ctx.lookup (&quot;myTopic&quot;);  //create TopicSubscriber  </span><br><span class="line">TopicSubscriber receiver = ses.createSubscriber(t);</span><br></pre></td></tr></table></figure>
<h3 id="连接（Connection）"><a href="#连接（Connection）" class="headerlink" title="连接（Connection）"></a>连接（Connection）</h3><p>连接对象封装了与JMS提供者之间的虚拟连接，如果我们有一个ConnectionFactory对象，可以使用它来创建一个连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = connectionFactory.createConnection();</span><br></pre></td></tr></table></figure>
<p>创建完连接后，需要在程序使用结束后关闭它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
<h3 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h3><p>Session是一个单线程上下文，用于生产和消费消息，可以创建出消息生产者和消息消费者。</p>
<p>Session对象实现了Session接口，在创建完连接后，我们可以使用它创建Session。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/java面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/java面试题/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:22+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul>
<li>面向过程：<ul>
<li>优点：性能比比面向对象高，在注重性能的单片机、嵌入式开发、Linux/Unix开发中使用面向过程进行开发</li>
<li>缺点：没有面向对象容易维护、易复用、易拓展</li>
</ul>
</li>
<li>面向对象：<ul>
<li>优点：易维护、易复用、易拓展，面向对象有封装、继承、多态的特性，因此能设计出低耦合系统</li>
<li>缺点：性能表现比较差，类调用时需要实例化，开销比较大，消耗资源</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h3><ol>
<li>简单易学</li>
<li>面向对象（封装、继承、多态）</li>
<li>平台无关性</li>
<li>可靠性</li>
<li>安全性</li>
<li>支持多线程</li>
<li>支持网络编程</li>
<li>编译与解释并行</li>
</ol>
</li>
<li><h3 id="JDK、JRE、JVM三者联系与区别"><a href="#JDK、JRE、JVM三者联系与区别" class="headerlink" title="JDK、JRE、JVM三者联系与区别"></a>JDK、JRE、JVM三者联系与区别</h3><ul>
<li>JDK：给开发者提供的开发工具包，包括JRE、java运行环境和其它工具包</li>
<li>JRE（Java Runtime Environment）：普通用户只需要安装JRE来运行程序</li>
<li>JVM：负责将字节码转换为特定机器码，还有内存管理/垃圾回收和安全机制</li>
<li>区别与联系：<ol>
<li>JDK用于开发，JRE用于运行Java程序</li>
<li>JDK和JRE都包含JVM</li>
<li>JVM是Java编程语言的核心，具有平台独立性</li>
</ol>
</li>
</ul>
</li>
<li><h3 id="字节码——编译与解释并行的关键"><a href="#字节码——编译与解释并行的关键" class="headerlink" title="字节码——编译与解释并行的关键"></a>字节码——编译与解释并行的关键</h3><p>编译程序只需要面向虚拟机，生成虚拟机可以理解的代码，然后由解释器来将虚拟机代码转换为系统特有的机器码执行。这种供虚拟机理解的代码称为 <strong>字节码</strong> （拓展名.class）</p>
<p>Java源代码=&gt;编译器=&gt;jvm可执行的Java字节码=&gt;jvm=&gt;jvm中的解释器=&gt;机器可执行的二进制机器码=&gt;程序运行</p>
</li>
<li><h3 id="java与C-区别"><a href="#java与C-区别" class="headerlink" title="java与C++区别"></a>java与C++区别</h3><ul>
<li>都是面向对象的语言，都支持封装、继承、多态</li>
<li>Java不提供指针来直接访问内存，程序内存更安全</li>
<li>Java的类是单继承的，C++支持多重继承；但是Java的接口可以多继承</li>
<li>Java有自动内存管理机制</li>
</ul>
</li>
<li><h3 id="Java应用程序与小程序之间的差别"><a href="#Java应用程序与小程序之间的差别" class="headerlink" title="Java应用程序与小程序之间的差别"></a>Java应用程序与小程序之间的差别</h3><p>应用程序从主线程启动（main()方法）。applet小程序没有main()方法，主要是嵌在浏览器页面上运行（init()方法、run()方法）</p>
</li>
<li><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><ul>
<li>重载：发生在同一个类中，方法名必须相同，参数类型、参数数目、参数顺序、方法返回值、访问修饰符可以不同；发生在编译期间</li>
<li>重写：发生在父子类中，方法名、参数必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类访问修饰符为private则不能重写该方法</li>
</ul>
</li>
<li><h3 id="在类中定义一个空构造方法作用"><a href="#在类中定义一个空构造方法作用" class="headerlink" title="在类中定义一个空构造方法作用"></a><strong>在类中定义一个空构造方法作用</strong></h3><p>Java在执行子类的构造方法前，如果没有用super()来调用父类特定的构造方法，则会调用没有参数的构造方法。因此如果没有定义相关构造方法，则会在编译期间抛出错误。</p>
</li>
<li><h3 id="与equals"><a href="#与equals" class="headerlink" title="== 与equals"></a>== 与equals</h3><ul>
<li>==：判断两个对象的地址是不是相等。（基本数据类型==比较的是值、引用数据类型==比较的是内存地址）</li>
<li>equals()：类中没有覆盖此方法时，调用该方法等于使用“==”；类重写了此方法，则按照类中的方法判断，比如String中的equals()是比较对象的值，而object的equals()是比较对象的内存地址</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/cookie与session/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/cookie与session/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:22+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/guoweimelon/article/details/50886092" target="_blank" rel="noopener">https://blog.csdn.net/guoweimelon/article/details/50886092</a></p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie机制采用的是在客户端保持状态的方案</p>
<p>网站为了<strong>辨别用户身份</strong>、<strong>进行session跟踪</strong>而储存在<strong>客户端</strong>的数据。（通常经过加密）</p>
<p>由服务端生成，发送给客户端。按照在客户端中储存位置可以分为：内存cookie和硬盘cookie。</p>
<p>内存cookie：</p>
<p>由浏览器维护，保存在内存中，浏览器关闭后就消失了</p>
<p>硬盘cookie</p>
<p>保存在硬盘中，设置生存时间。手动删除和到了生存时间自动删除。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li><h5 id="创建cookie"><a href="#创建cookie" class="headerlink" title="创建cookie"></a>创建cookie</h5></li>
</ol>
<ul>
<li>当用户第一次浏览网站，<strong>服务器</strong>进行以下工作</li>
<li>生成唯一的一个识别码（cookie id），创建一个cookie对象；</li>
<li>默认是会话级别的cookie，储存在内存中，退出浏览器就会被删除。设置了最大生存周期（maxAge），就会存储在硬盘中。</li>
<li>cookie放入http响应报头，将cookie插入到Set-Cookie HTTP请求报头中。</li>
<li>发送HTTP响应报文。</li>
</ul>
<ol start="2">
<li><h5 id="设置储存cookie"><a href="#设置储存cookie" class="headerlink" title="设置储存cookie"></a>设置储存cookie</h5></li>
</ol>
<p>浏览器收到响应报文，会根据Set-Cookie的指示，生成相应的cookie，保存在客户端，该cookie记录着用户当前的信息。</p>
<ol start="3">
<li><h5 id="发送cookie"><a href="#发送cookie" class="headerlink" title="发送cookie"></a>发送cookie</h5></li>
</ol>
<p>再次访问该网站，会首先检查储存的cookies，如果存在该网站的cookie（即cookie所声明的作用范围大于等于将要请求的资源），则把该cookie放在请求资源的http报文请求头上发送给服务器。</p>
<ol start="4">
<li><h5 id="读取cookie"><a href="#读取cookie" class="headerlink" title="读取cookie"></a>读取cookie</h5></li>
</ol>
<p>服务器接受到请求报文，从报文头部获取用户的cookie。</p>
<p>####可以实现的功能：</p>
<ol>
<li>自动登录</li>
<li>购物车功能</li>
<li>记录用户浏览数据，广告推送</li>
</ol>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>cookie附加在HTTP请求，增加流量</p>
<p>HTTP中cookie是明文传递 </p>
<p>cookie大小在4KB左右</p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session代表服务器的一次会话过程，可以是连续的，也可以是时断时续的。</p>
<p>由服务器生成，保存在服务器的内存、缓存、硬盘或数据库中。</p>
<p>session机制采用的是在服务器端保持状态的方案。</p>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><ol>
<li>创建session</li>
</ol>
<p>当用户访问到一个服务器，如果服务器启用了session。服务器就要为用户创建 一个session。</p>
<p>在创建session的时候，首先检查用户发来的请求报文汇总是否包含了一个session id，如果有则说明该用户之前访问过服务器，就会根据这个session id将在服务器内存中的session找出来（找不到就会重新创建一个），如果请求报文中没有这个session id，则为该客户端创建一个session并生成一个对应的session id。</p>
<p>session id是唯一的，不重复的，不容易找到规律的字符串。</p>
<p>session id会被保存在本次响应中，返回客户端保存，保存方式正是cookie。</p>
<ol start="2">
<li>使用session</li>
</ol>
<p>如果禁止了cookie，session id仍然可以继续使用，方法为：<strong>URL重写</strong>和<strong>表单隐藏字段</strong></p>
<p>URL重写：把session id直接附加在URL路径后面表现形式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://…./xxx;jSession=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764；</span><br></pre></td></tr></table></figure>
<p>或者作为查询字符串附加在URL后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://…../xxx?jSession=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764</span><br></pre></td></tr></table></figure>
<p>表单隐藏字段：</p>
<p>服务器自动修改表单，添加一个隐藏字段，在提交表单时能把session id传会服务器。</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>判断用户是否曾经登录过</p>
<p>购物车功能</p>
<h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><ol>
<li>存放位置不同</li>
</ol>
<p>cookie放在客户端，session放在服务端</p>
<ol start="2">
<li>存取方式</li>
</ol>
<p>cookie只能保管ASCII字符串，假如需要存取Unicode字符或者二进制数据，需要先进行编码。cookie也不能直接存取java对象</p>
<p>session可以存取任何类型的数据，能直接保管java bean，可以把session看作是一个java容器类。</p>
<ol start="3">
<li>安全性（隐私策略）</li>
</ol>
<p>cookie存储在浏览器中，对用户可见，一些程序可能会窥探用户的cookie</p>
<p>session放在服务器中，对用户透明</p>
<p>使用建议：敏感的信息如帐号密码等不要写在cookie中，最好是先进行加密，提交到服务器之后在进行解密。</p>
<ol start="4">
<li>有效期</li>
</ol>
<p>可以将cookie的生存时间设置为一个很大的数字，cookie就会在浏览器保存很长时间。由于session依赖于session id这一cookie，而该数据过期时间默认为-1，即关闭浏览器（一次会话结束）就会失效</p>
<ol start="5">
<li>对服务器的压力</li>
</ol>
<p>session保存在服务器中，每个用户都会生成一个session，假如用户达到一定数量就会耗费大量的内存</p>
<p>cookie保存在客户端，不占用服务器资源。</p>
<ol start="6">
<li>跨域支持</li>
</ol>
<p>cookie支持跨域名访问，假如将domain属性设置为“baidu.com”，则以“baidu.com”为后缀的一切域名都可以访问cookie</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/网络协议/UDP&DHCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/网络协议/UDP&DHCP/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:20+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>UDP（User Datagram Protocol）用户数据包协议用于实现面向无连接和不可靠传输服务。</p>
<ul>
<li>简单小巧，速度快</li>
<li>用于传输小数据流</li>
</ul>
<p>QQ、DHCP协议、DNS协议基于UDP</p>
<p>常用端口号：</p>
<ul>
<li>20/21：ftp</li>
<li>22：ssh</li>
<li>23：telnet</li>
<li>25：smtp</li>
<li>53：dns</li>
<li>67/68:dhcp</li>
<li>80:http</li>
<li>443:https</li>
<li>4000/8000:qq    oicq</li>
</ul>
<p>DHCP(Dynamic Configuration Protocol)动态主机配置协议，用于动态配置IP信息（地址、网关、DNS等）</p>
<p>原理：</p>
<p>-&gt;DHCP Discover(发现)</p>
<p>-&lt;DHCP offer（提供）</p>
<p>-&gt;DHCP request（请求）</p>
<p>-&lt;DHCP ACK（确认）</p>
<p>question：</p>
<ol>
<li>当主机没有ip地址是，如何发DHCP包</li>
</ol>
<p>0.0.0.0 全网地址/置空地址</p>
<ol start="2">
<li>为什么需要4个包， 2个包不能获取ip地址吗</li>
</ol>
<p>考虑多个DHCP服务器的环境，会造成地址浪费</p>
<p>​ps：DHCP先到先得原则-谁先给offer，就向谁请求</p>
<ol start="3">
<li>如何解决地址冲突</li>
</ol>
<p>255.255.255.255–广播地址，解决地址冲突问题（也结合了免费ARP）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/网络协议/TCP&telnet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/网络协议/TCP&telnet/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:20+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="TCP（Trajnsmission-Control-Potocol）传输控制协议"><a href="#TCP（Trajnsmission-Control-Potocol）传输控制协议" class="headerlink" title="TCP（Trajnsmission Control Potocol）传输控制协议"></a>TCP（Trajnsmission Control Potocol）传输控制协议</h3><ol>
<li>面向连接（三次握手、四次挥手）</li>
<li>可靠传输（序列号/确认号， 重传机制）</li>
<li>流量控制（滑动窗口）</li>
<li>多路复用</li>
</ol>
<p>telnet远程登录</p>
<p><img src="1531666691866.png" alt></p>
<h3 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h3><ol>
<li>客户端发送SYN</li>
<li>服务端收到后，回发ACK+SYN</li>
<li>客户端发送ACK</li>
</ol>
<p><img src="1531666718468.png" alt></p>
<h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><ol>
<li><p>客户端发送FIN</p>
</li>
<li><p>服务端发送ACK</p>
<p>中间可以有数据传输</p>
</li>
<li><p>服务端发送FIN</p>
</li>
<li><p>客户端发送ACK</p>
</li>
</ol>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul>
<li>使用滑动窗口进行控制</li>
<li>接受方在建立连接时会有一个窗口大小（rwnd = ‘400’， 表示要求发送400个字节）,发送确认ACK的时候会将rwnd一起发过去。</li>
<li>当接受方窗口为0之后，发送方会暂停，直到接受发送自己需要的rwnd。但是这个报文段会丢失，这时两方都在等，一段时间后发送方发个一字节的探测报文段。</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ol>
<li><p><strong>慢开始</strong>和<strong>拥塞避免</strong>：</p>
<p>发送方维持一个<strong>拥塞窗口</strong>（cwnd=1），大小取决于网络拥塞状况</p>
<ul>
<li>慢开始： 设置一个最大报文段（MSS），每次收到确认报文后 cwnd增加一个MSS</li>
<li>拥塞避免： 设慢开始门限（ssthresh），超过这个值就开始拥塞避免</li>
</ul>
</li>
<li><p><strong>快重传</strong>与<strong>快恢复</strong></p>
<ul>
<li>快重传：当发送方连续收到三个重复确认时（网络开始拥塞），重新开始慢开始过程</li>
<li>快恢复：当出现快重传的时候不执行慢开始，而是从慢开始门限（ssthresh）开始拥塞避免算法</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">李楚豪的博客</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">85</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李楚豪的博客</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
