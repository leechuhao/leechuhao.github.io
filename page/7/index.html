<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/SpringBoot/启动过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/SpringBoot/启动过程/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SpringApplication的run方法的实现是我们本次旅程的主要线路，该方法的主要流程大体可以归纳如下：</p>
<p>1） 如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</p>
<ul>
<li>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li>
<li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li>
<li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li>
<li>推断并设置main方法的定义类。</li>
</ul>
<p>2） SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。</p>
<p>3） 创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。</p>
<p>4） 遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</p>
<p>5） 如果SpringApplication的showBanner属性被设置为true，则打印banner。</p>
<p>6） 根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</p>
<p>7） ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。</p>
<p>8） 遍历调用所有SpringApplicationRunListener的contextPrepared()方法。</p>
<p>9） 最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。</p>
<p>10） 遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</p>
<p>11） 调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p>
<p>12） 查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</p>
<p>13） 正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）<br>去除事件通知点后，整个流程如下：</p>
<p><img src="../../images/1240" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/重定向和转发的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/重定向和转发的区别/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="forward（转发）"><a href="#forward（转发）" class="headerlink" title="forward（转发）"></a>forward（转发）</h3><ul>
<li>服务器请求资源，服务器直接访问URL地址，将对应的网页内容读取，再将这些内容发送给客户端，地址栏的URL没有改变</li>
<li>可以获得request中的数据，比如cookie信息</li>
<li>转发过程：<ol>
<li>客户浏览器发送http请求</li>
<li>web服务器接受此请求</li>
<li>调用内部的一个方法在容器内部完成请求处理和转发动作</li>
<li>将目标资源发送给客户</li>
</ol>
</li>
</ul>
<p>在这里，转发的路径必须是同一个web容器下的url，其不能转向到其他的web路径上去，中间传递的是自己的容器内的request。在客户浏览器路径栏显示的仍然是其第一次访问的路径，也就是说客户是感觉不到服务器做了转发的。转发行为是浏览器只做了一次访问请求。</p>
<h3 id="redirect（重定向）"><a href="#redirect（重定向）" class="headerlink" title="redirect（重定向）"></a>redirect（重定向）</h3><ul>
<li>服务器发送一个状态码，告诉浏览器去访问另一个URL，地址栏的URL会改变</li>
<li>转发是服务器行为，重定向是客户端行为</li>
<li>重定向过程：<ol>
<li>客户浏览器发送http请求</li>
<li>web服务器接受后发送302状态码响应及对应新的location给客户浏览器</li>
<li>客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址</li>
<li>服务器根据此请求寻找资源并发送给客户。</li>
</ol>
</li>
</ul>
<p>在这里 location可以重定向到任意URL，既然是浏览器重新发出了请求，则就没有什么request传递的概念了。在客户浏览器路径栏显示的是其重定向的路径，客户可以观察到地址的变化的。重定向行为是浏览器做了至少两次的访问请求的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/游戏服务器架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/游戏服务器架构/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="..\images/游戏服务器.png" alt="png"></p>
<p>各个服务器的功能以及作用</p>
<ul>
<li>CenterServer服务器管理器</li>
</ul>
<p>管理所有的服务器，分配服务器的端口，负责全局的逻辑（管理），对各功能服务器</p>
<p>和场景服务器提供服务，保证服务器的合法性</p>
<ul>
<li>DBserver</li>
</ul>
<p>角色档案缓冲服务器</p>
<ul>
<li>GameServer</li>
</ul>
<p>逻辑服务器，玩家的实时同步在里面实现</p>
<ul>
<li>GateServer</li>
</ul>
<p>网关服务器，负责消息转发</p>
<ul>
<li>LoginServer登录服务器</li>
</ul>
<p>连接账号数据</p>
<p>带负载均衡的（与带负载均衡大概的架构相同）</p>
<p>不同点：</p>
<ul>
<li>不带负载均衡</li>
</ul>
<ol>
<li>Gate Server 和Game Server之间是一对一的关系，每个Game Server能容纳的玩家数量是一定的，正常情况下一个Gate Server的对应一个Game Server实时在线人数能达到3000人，一旦达到峰值，就会找下一个对应的Game Server</li>
<li>各个Gate Server服务器之间是不通信的</li>
</ol>
<ul>
<li>带负载均衡</li>
</ul>
<ol>
<li>一个Gate Server的对应多个Game Server</li>
<li>各个GateServer之间可以互相通信，而且还可以随意扩展，通过配置文件可以实现配置</li>
</ol>
<p>服务器的工作过程：</p>
<p>1)     用户从客户端选择游戏服务器列表</p>
<p>2)     登录到Login Server,在登陆的过程中</p>
<p>3)     先去平台服务器进行账号的验证</p>
<p>4)     验证通过后会通知Login Server，然后Login Server会把验证的消息发送到center Server，请求其中的Gate Server的地址和端口</p>
<p>5)     Center Server会找一个可用的Gate Server信息,发送回LoginServer</p>
<p>6)     Login Server会把消息发送给客户端</p>
<p>7)     客户端断开与Login Server的连接，然后与Game Server 连接进入游戏场景中</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/ZooKeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/ZooKeeper/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.cnblogs.com/felixzh/p/5869212.html" target="_blank" rel="noopener">ZooKepper</a></p>
<ol>
<li><p>ZooKeeper是什么？<br>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户</p>
</li>
<li><p>ZooKeeper提供了什么？</p>
<ol>
<li>文件系统</li>
<li>通知机制</li>
</ol>
</li>
<li><p>Zookeeper文件系统</p>
</li>
</ol>
<p>每个子目录项如 NameService 都被称作为znode，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。 </p>
<p>有四种类型的znode： </p>
<p>1、PERSISTENT-持久化目录节点 </p>
<p>客户端与zookeeper断开连接后，该节点依旧存在 </p>
<p>2、PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点 </p>
<p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号 </p>
<p>3、EPHEMERAL-临时目录节点 </p>
<p>客户端与zookeeper断开连接后，该节点被删除 </p>
<p>4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点 </p>
<p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号 </p>
<p><img src="1535378751702.png" alt="1535378751702"></p>
<ol start="4">
<li>Zookeeper通知机制</li>
</ol>
<p>客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。</p>
<ol start="5">
<li>Zookeeper做了什么？</li>
</ol>
<p>1.命名服务   2.配置管理   3.集群管理   4.分布式锁  5.队列管理</p>
<ol start="6">
<li>Zookeeper命名服务</li>
</ol>
<p>在zookeeper的文件系统里创建一个目录，即有唯一的path。在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path，通过path即能互相探索发现。</p>
<ol start="7">
<li>Zookeeper的配置管理</li>
</ol>
<p>程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。现在把这些配置全部放到zookeeper上去，保存在 Zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中就好</p>
<p><img src="1535378784883.png" alt="1535378784883"></p>
<ol start="8">
<li>Zookeeper集群管理</li>
</ol>
<p>所谓集群管理无在乎两点：是否有机器退出和加入、选举master。 </p>
<p>对于第一点，所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。</p>
<p>新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。</p>
<p><img src="1535378814030.png" alt="1535378814030"></p>
<ol start="9">
<li>Zookeeper分布式锁</li>
</ol>
<p>有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。 </p>
<p>对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。 </p>
<p>对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。</p>
<p><img src="1535378831004.png" alt="1535378831004"></p>
<ol start="10">
<li>Zookeeper队列管理</li>
</ol>
<p>两种类型的队列：</p>
<p>1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。 </p>
<p>2、队列按照 FIFO 方式进行入队和出队操作。 </p>
<p>第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。 </p>
<p>第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。</p>
<ol start="11">
<li>分布式与数据复制 </li>
</ol>
<p>Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处： </p>
<pre><code>1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作； 

2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力； 

3、提高性能：让客户端本地访问就近的节点，提高用户访问速度。 
</code></pre><p>从客户端读写访问的透明度来看，数据复制集群系统分下面两种： </p>
<pre><code>1、写主(WriteMaster) ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离； 

2、写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。
</code></pre><p>对zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p>
<ol start="12">
<li>Zookeeper角色描述</li>
</ol>
<p><img src="1535378858358.png" alt="1535378858358"></p>
<ol start="13">
<li>Zookeeper与客户端</li>
</ol>
<p><img src="1535378872745.png" alt="1535378872745"></p>
<ol start="14">
<li><p>Zookeeper设计目的</p>
<ul>
<li><p>最终一致性：client不论连接到哪个Server，展示给它都是同一个视图，这是zookeeper最重要的性能。 </p>
</li>
<li><p>可靠性：具有简单、健壮、良好的性能，如果消息被到一台服务器接受，那么它将被所有的服务器接受。 </p>
</li>
<li><p>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。 </p>
</li>
<li><p>等待无关（wait-free）：慢的或者失效的client不得干预快速的client的请求，使得每个client都能有效的等待。 </p>
</li>
<li><p>原子性：更新只能成功或者失败，没有中间状态。 </p>
</li>
<li><p>顺序性：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有Server上消息a都将在消息b前被发布；偏序是指如果一个消息b在消息a后被同一个发送者发布，a必将排在b前面。 </p>
</li>
</ul>
</li>
<li><p>Zookeeper工作原理</p>
</li>
</ol>
<p>Zookeeper 的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和 leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。 </p>
<p>为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</p>
<ol start="16">
<li>Zookeeper 下 Server工作状态</li>
</ol>
<p>每个Server在工作过程中有三种状态： </p>
<p>LOOKING：当前Server不知道leader是谁，正在搜寻<br>LEADING：当前Server即为选举出来的leader<br>FOLLOWING：leader已经选举出来，当前Server与之同步</p>
<ol start="17">
<li>Zookeeper选主流程(basic paxos)</li>
</ol>
<p>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。</p>
<p>1.选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server； </p>
<p>2.选举线程首先向所有Server发起一次询问(包括自己)； </p>
<p>3.选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中； </p>
<p>4.收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server； </p>
<p>5.线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数，设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。 通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1. 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图所示： </p>
<p><img src="1535378953534.png" alt="1535378953534"></p>
<ol start="18">
<li>Zookeeper选主流程（fast paxos）</li>
</ol>
<p>fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和 zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。</p>
<p><img src="1535378971998.png" alt="1535378971998"></p>
<ol start="19">
<li>Zookeeper同步流程</li>
</ol>
<p>选完Leader以后，zk就进入状态同步过程。 </p>
<ol>
<li><p>Leader等待server连接； </p>
</li>
<li><p>Follower连接leader，将最大的zxid发送给leader； </p>
</li>
<li><p>Leader根据follower的zxid确定同步点； </p>
</li>
<li><p>完成同步后通知follower 已经成为uptodate状态； </p>
</li>
<li><p>Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</p>
</li>
</ol>
<p><img src="1535378991331.png" alt="1535378991331"></p>
<ol start="20">
<li><p>Zookeeper工作流程-Leader</p>
</li>
<li><p>恢复数据； </p>
</li>
<li><p>维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型； </p>
</li>
<li><p>Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。 </p>
</li>
</ol>
<p>PING 消息是指Learner的心跳信息；</p>
<p>REQUEST消息是Follower发送的提议信息，包括写请求及同步请求；</p>
<p>ACK消息是 Follower的对提议的回复，超过半数的Follower通过，则commit该提议；</p>
<p>REVALIDATE消息是用来延长SESSION有效时间。</p>
<p><img src="1535379032405.png" alt="1535379032405"></p>
<p>21.Zookeeper工作流程-Follower</p>
<p>Follower主要有四个功能： </p>
<p>1.向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）； </p>
<p>2.接收Leader消息并进行处理； </p>
<p>3.接收Client的请求，如果为写请求，发送给Leader进行投票；</p>
<p>4.返回Client结果。 </p>
<p>Follower的消息循环处理如下几种来自Leader的消息： </p>
<p>1 .PING消息： 心跳消息； </p>
<p>2 .PROPOSAL消息：Leader发起的提案，要求Follower投票； </p>
<p>3 .COMMIT消息：服务器端最新一次提案的信息； </p>
<p>4 .UPTODATE消息：表明同步完成； </p>
<p>5 .REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息； </p>
<p>6 .SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</p>
<p><img src="1535379057410.png" alt="1535379057410"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/SSM框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/SSM框架/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SSM框架是包含spring MVC，spring和 mybatis 框架的整合，标准的MVC模式。</p>
<p>将系统分为：View层、controller层、service层和DAO层。</p>
<p>spring MVC：请求的转发和视图管理</p>
<ol>
<li>客户端发送请求到 DIspacherServlet（分发器）</li>
<li>由DispacherServlet控制器查询 HanderMapping，找到处理请求的Controller</li>
<li>Controller调用业务逻辑处理，返回ModelAndView</li>
<li>DispacherServlet查询视图解析器，找到ModelAndView指定的视图</li>
<li>视图负责显示到客户端</li>
</ol>
<p><img src="1534331765269.png" alt="1534331765269"></p>
<p>spring：实现业务对象管理</p>
<ol>
<li>Ioc容器（控制转移、控制反转）：装载Bean，使用的时候不需要进行初始化（new），直接调用即可。</li>
<li>aop（切面）：面向切面、切入点的编程</li>
</ol>
<p>mybatis：数据对象的持久化引擎</p>
<ol>
<li>mybatis是对jdbc的封装，使得数据库操作变得透明。</li>
<li>mybatis围绕着 sqlSessionFactory 实例展开</li>
<li>通过配置文件关联到各个实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需的sql语句映射</li>
<li>每次与数据库进行交互时，通过sqlSessionFactory拿到一个sqlSession，在执行sql命令</li>
</ol>
<h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><p>要完成一个功能：</p>
<ol>
<li>先写实体类entity，定义对象的属性，（可以参照数据库中表的字段来设置，数据库的设计应该在所有编码开始之前）。</li>
<li>写Mapper.xml（Mybatis），其中定义你的功能，对应要对数据库进行的那些操作，比如 insert、selectAll、selectByKey、delete、update等。</li>
<li>写Mapper.java，将Mapper.xml中的操作按照id映射成Java函数。</li>
<li>写Service.java，为控制层提供服务，接受控制层的参数，完成相应的功能，并返回给控制层。</li>
<li>写Controller.java，连接页面请求和服务层，获取页面请求的参数，通过自动装配，映射不同的URL到相应的处理函数，并获取参数，对参数进行处理，之后传给服务层。</li>
<li>写JSP页面调用，请求哪些参数，需要获取什么数据。</li>
</ol>
<p>DataBase ===&gt; Entity ===&gt; Mapper.xml ===&gt; Mapper.Java ===&gt; Service.java ===&gt; Controller.java ===&gt; Jsp.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/SSH框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/SSH框架/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于SSH框架： SSH框架则是Struts2，Spring和Hibernate框架的整合，其中Struts2 做控制器(controller)，spring 管理各层的组件，hibernate 负责持久化层。 </p>
<h3 id="hibernate"><a href="#hibernate" class="headerlink" title="hibernate"></a>hibernate</h3><ol>
<li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。</li>
<li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li>
<li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</li>
<li>hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 原理： <ol>
<li>通过Configuration().configure();读取并解析hibernate.cfg.xml配置文件 </li>
<li>由hibernate.cfg.xml中的读取并解析映射信息 </li>
<li>通过config.buildSessionFactory();//创建SessionFactory </li>
<li>sessionFactory.openSession();//打开Sesssion </li>
<li>session.beginTransaction();//创建事务Transation </li>
<li>persistent operate持久化操作 </li>
<li>session.getTransaction().commit();//提交事务 </li>
<li>关闭Session </li>
<li>关闭SesstionFactory</li>
</ol>
</li>
</ol>
<h3 id="Struts2"><a href="#Struts2" class="headerlink" title="Struts2"></a>Struts2</h3><p>Struts 2框架本身大致可以分为3个部分：核心控制器FilterDispatcher、业务控制器Action和用户实现的企业业务逻辑组件。</p>
<p>核心控制器FilterDispatcher是Struts2框架的基础，包含了框架内部的控制流程和处理机制。</p>
<p>业务控制器Action和业务逻辑组件是需要用户来自己实现的。用户在开发Action和业务逻辑组件的同时，还需要编写相关的配置文件，供核心控制器FilterDispatcher来使用。 </p>
<p>Struts2的工作流程相对于Struts1要简单，与WebWork框架基本相同，所以说Struts2是WebWork的升级版本。基本简要流程如下：</p>
<ol>
<li>客户端浏览器发出HTTP请求。</li>
<li>根据web.xml配置，该请求被FilterDispatcher接收。</li>
<li>根据struts.xml配置，找到需要调用的Action类和方法， 并通过IoC方式，将值注入给Aciton。</li>
<li>Action调用业务逻辑组件处理业务逻辑，这一步包含表单验证。</li>
<li>Action执行完毕，根据struts.xml中的配置找到对应的返回结果result，并跳转到相应页面。</li>
<li>返回HTTP响应到客户端浏览器。</li>
</ol>
<p><img src="1535718257997.png" alt="1535718257997"></p>
<p>Struts的工作流程: </p>
<ul>
<li>在web应用启动时就会加载初始化ActionServlet,</li>
<li>ActionServlet从 struts-config.xml文件中读取配置信息,把它们存放到各种配置对象 当ActionServlet接收到一个客户请求时,将执行如下流程. <ol>
<li>检索和用户请求匹配的ActionMapping实例,如果不存在,就返回请求路径无效信息;</li>
<li>如果ActionForm实例不存在,就创建一个ActionForm对象,把客户提交的表单数据保存到ActionForm对象中; </li>
<li>根据配置信息决定是否需要表单验证.如果需要验证,就调用ActionForm的validate()方法; </li>
<li>如果ActionForm的validate()方法返回null或返回一个不包含ActionMessage的ActuibErrors对象, 就表示表单验证成功; </li>
<li>ActionServlet根据ActionMapping所包含的映射信息决定将请求转发给哪个Action,如果相应的 Action实例不存在,就先创建这个实例,然后调用Action的execute()方法; </li>
<li>Action的execute()方法返回一个ActionForward对象,ActionServlet在把客户请求转发给 ActionForward对象指向的JSP组件; </li>
<li>ActionForward对象指向JSP组件生成动态网页,返回给客户;</li>
</ol>
</li>
</ul>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式。 组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下： </p>
<ul>
<li>核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。</li>
</ul>
<p>IOC 和 AOP 控制反转模式（也称作依赖性介入）的基本概念是：不创建对象，但是描述创建它们的方式。在代码中不直接与对象和服务连接，但在配置文件中描述哪一个组件需要哪一项服务。容器（在 Spring 框架中是 IOC 容器） 负责将这些联系在一起。 在典型的 IOC 场景中，容器创建了所有对象，并设置必要的属性将它们连接在一起，决定什么时间调用方法。</p>
<p>Spring 设计的核心是 org.springframework.beans包，它的设计目标是与JavaBean组件一起使用。这个包通常不是由用户直接使用，而是由服务器将其用作其他多数功能的底层中介。下一个最高级抽象是BeanFactory接口，它是工厂设计模式的实现，允许通过名称创建和检索对象。BeanFactory 也可以管理对象之间的关系。 </p>
<p>BeanFactory 支持两个对象模型。</p>
<ul>
<li><p>单态 模型提供了具有特定名称的对象的共享实例，可以在查询时对其进行检索。Singleton 是默认的也是最常用的对象模型。对于无状态服务对象很理想。 </p>
</li>
<li><p>原型 模型确保每次检索都会创建单独的对象。在每个用户都需要自己的对象时，原型模型最适合。 </p>
</li>
</ul>
<p>bean 工厂的概念是 Spring 作为 IOC 容器的基础。IOC 将处理事情的责任从应用程序代码转移到框架。正如我将在下一个示例中演示的那样，Spring 框架使用 JavaBean 属性和配置数据来指出必须设置的依赖关系。 BeanFactory 接口 因为 org.springframework.beans.factory.BeanFactory 是一个简单接口，所以可以针对各种底层存储方法实现。最常用的 BeanFactory 定义是 XmlBeanFactory，它根据 XML 文件中的定义装入 bean，在 XML 文件中定义的 Bean 是被消极加载的，这意味在需要 bean 之前，bean 本身不会被初始化。要从 BeanFactory 检索 bean，只需调用 getBean() 方法，传入将要检索的 bean 的名称即可，每个 bean 的定义都可以是 POJO （用类名和 JavaBean 初始化属性定义） 或 FactoryBean。FactoryBean 接口为使用 Spring 框架构建的应用程序添加了一个间接的级别。 </p>
<p>总结：SSM和SSH不同主要在MVC实现方式，以及ORM持久化方面不同（Hiibernate与Mybatis）。SSM越来越轻量级配置，将注解开发发挥到极致，且ORM实现更加灵活，SQL优化更简便；而SSH较注重配置开发，其中的Hiibernate对JDBC的完整封装更面向对象，对增删改查的数据维护更自动化，但SQL优化方面较弱，且入门门槛稍高。</p>
<p>作者：伊竹凌</p>
<p>链接：<a href="https://juejin.im/post/5a715f4ef265da3e5a57935f" target="_blank" rel="noopener">https://juejin.im/post/5a715f4ef265da3e5a57935f</a></p>
<p>来源：掘金</p>
<p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/Spring面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/Spring面试题/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><h3 id="Spring中IOC容器Bean的生命周期"><a href="#Spring中IOC容器Bean的生命周期" class="headerlink" title="Spring中IOC容器Bean的生命周期"></a>Spring中IOC容器Bean的生命周期</h3><ol>
<li>Bean实例化  </li>
<li>属性注入  </li>
<li>BeanFactory   </li>
<li>ApplicationContext  </li>
<li>postProcessBeforeInitialization</li>
<li>initializingBean接口（或者自定义接口） </li>
<li>postProcessAfterInitialization</li>
</ol>
<p>相关接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bean的生命周期 </span><br><span class="line">BeanNameAware:Bean可以获取在BeanFactory中的名称 </span><br><span class="line">BeanFactoryAware：Bean可以获取所在的BeanFactory对象 </span><br><span class="line">ApplicationContextAware：可以获取Bean所在的ApplicationContext </span><br><span class="line">InitializingBean:Bean属性设置完成后的自定义操作接口：例如设置自定义的初始化方法init-method </span><br><span class="line">DisposableBean：销毁Bean的相关资源</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="Spring中Bean的作用域"><a href="#Spring中Bean的作用域" class="headerlink" title="Spring中Bean的作用域"></a>Spring中Bean的作用域</h3><ol>
<li>singleton</li>
<li>prototype</li>
<li>request</li>
<li>session</li>
<li>global session</li>
</ol>
<p><img src="../images/242025553_1552555606893_F700E1D9126F56CAD8981C82A6A243D0" alt="img"></p>
</li>
<li></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/Spring中获取request的几种方法，及其线程安全性分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/Spring中获取request的几种方法，及其线程安全性分析/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>来源：<a href="www.cnblogs.com/kismetv/p/8757260.html">编程迷思</a></p>
</blockquote>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>在使用Spring MVC开发Web系统时，经常需要在处理请求时使用request对象，比如获取客户端ip地址、请求的url、header中的属性（如cookie、授权信息）、body中的数据等。由于在Spring MVC中，处理请求的Controller、Service等对象都是单例的，因此获取request对象时最需要注意的问题，便是request对象是否是线程安全的：当有大量并发请求时，能否保证不同请求/线程中使用不同的request对象。</p>
<p>这里还有一个问题需要注意：前面所说的“在处理请求时”使用request对象，究竟是在哪里使用呢？考虑到获取request对象的方法有微小的不同，大体可以分为两类：</p>
<ol>
<li>在Spring的Bean中使用request对象：既包括Controller、Service、Repository等MVC的Bean，也包括了Component等普通的Spring Bean。为了方便说明，后文中Spring中的Bean一律简称为Bean。</li>
<li>在非Bean中使用request对象：如普通的Java对象的方法中使用，或在类的静态方法中使用。</li>
</ol>
<p>此外，本文讨论是围绕代表请求的request对象展开的，但所用方法同样适用于response对象、InputStream/Reader、OutputStream/ Writer等；其中InputStream/Reader可以读取请求中的数据，OutputStream/ Writer可以向响应写入数据。</p>
<p>最后，获取request对象的方法与Spring及MVC的版本也有关系；本文基于Spring4进行讨论，且所做的实验都是使用4.1.1版本。</p>
<h3 id="如何测试线程安全性"><a href="#如何测试线程安全性" class="headerlink" title="如何测试线程安全性"></a><strong>如何测试线程安全性</strong></h3><p>既然request对象的线程安全问题需要特别关注，为了便于后面的讨论，下面先说明如何测试request对象是否是线程安全的。</p>
<p>测试的基本思路，是模拟客户端大量并发请求，然后在服务器判断这些请求是否使用了相同的request对象。</p>
<p>判断request对象是否相同，最直观的方式是打印出request对象的地址，如果相同则说明使用了相同的对象。然而，在几乎所有web服务器的实现中，都使用了线程池，这样就导致先后到达的两个请求，可能由同一个线程处理：在前一个请求处理完成后，线程池收回该线程，并将该线程重新分配给了后面的请求。而在同一线程中，使用的request对象很可能是同一个（地址相同，属性不同）。因此即便是对于线程安全的方法，不同的请求使用的request对象地址也可能相同。</p>
<p>为了避免这个问题，一种方法是在请求处理过程中使线程休眠几秒，这样可以让每个线程工作的时间足够长，从而避免同一个线程分配给不同的请求；另一种方法，是使用request的其他属性（如参数、header、body等）作为request是否线程安全的依据，因为即便不同的请求先后使用了同一个线程（request对象地址也相同），只要使用不同的属性分别构造了两次request对象，那么request对象的使用就是线程安全的。本文使用第二种方法进行测试。</p>
<p>客户端测试代码如下（创建1000个线程分别发送请求）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String prefix = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;) + &quot;::&quot;;</span><br><span class="line">        for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            final String value = prefix + i;</span><br><span class="line">            new Thread() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line">                        HttpGet httpGet = new HttpGet(&quot;http://localhost:8080/test?key=&quot; + value);</span><br><span class="line">                        httpClient.execute(httpGet);</span><br><span class="line">                        httpClient.close();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器中Controller代码如下（暂时省略了获取request对象的代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line"></span><br><span class="line">    // 存储已有参数，用于判断参数是否重复，从而判断线程是否安全</span><br><span class="line">    public static Set&lt;String&gt; set = new ConcurrentSkipListSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        // …………………………通过某种方式获得了request对象………………………………</span><br><span class="line"></span><br><span class="line">        // 判断线程安全</span><br><span class="line">        String value = request.getParameter(&quot;key&quot;);</span><br><span class="line">        if (set.contains(value)) &#123;</span><br><span class="line">            System.out.println(value + &quot;\t重复出现，request并发不安全！&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">            set.add(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 模拟程序执行了一段时间</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充：上述代码原使用HashSet来判断value是否重复，经网友批评指正，使用线程不安全的集合类验证线程安全性是欠妥的，现已改为ConcurrentSkipListSet。</p>
<p>如果request对象线程安全，服务器中打印结果如下所示：</p>
<p><img src="https://images2018.cnblogs.com/blog/1174710/201804/1174710-20180409091521700-337800932.png" alt="img"></p>
<p>如果存在线程安全问题，服务器中打印结果可能如下所示：</p>
<p><img src="https://images2018.cnblogs.com/blog/1174710/201804/1174710-20180409091542645-773381003.png" alt="img"></p>
<h3 id="方法1：Controller中加参数"><a href="#方法1：Controller中加参数" class="headerlink" title="方法1：Controller中加参数"></a><strong>方法1：Controller中加参数</strong></h3><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    public void test(HttpServletRequest request) throws InterruptedException &#123;</span><br><span class="line">        // 模拟程序执行了一段时间</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法实现的原理是，在Controller方法开始处理请求时，Spring会将request对象赋值到方法参数中。除了request对象，可以通过这种方法获取的参数还有很多，具体可以参见：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods</a></p>
<p>Controller中获取request对象后，如果要在其他方法中（如service方法、工具类方法等）使用request对象，需要在调用这些方法时将request对象作为参数传入。</p>
<h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h4><p>测试结果：线程安全</p>
<p>分析：此时request对象是方法参数，相当于局部变量，毫无疑问是线程安全的。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><p>这种方法的主要缺点是request对象写起来冗余太多，主要体现在两点：</p>
<ol>
<li>如果多个controller方法中都需要request对象，那么在每个方法中都需要添加一遍request参数</li>
<li>request对象的获取只能从controller开始，如果使用request对象的地方在函数调用层级比较深的地方，那么整个调用链上的所有方法都需要添加request参数</li>
</ol>
<p>实际上，在整个请求处理的过程中，request对象是贯穿始终的；也就是说，除了定时器等特殊情况，request对象相当于线程内部的一个全局变量。而该方法，相当于将这个全局变量，传来传去。</p>
<h3 id="方法2：自动注入"><a href="#方法2：自动注入" class="headerlink" title="方法2：自动注入"></a><strong>方法2：自动注入</strong></h3><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController&#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HttpServletRequest request; //自动注入request</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    public void test() throws InterruptedException&#123;</span><br><span class="line">        //模拟程序执行了一段时间</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程安全性-1"><a href="#线程安全性-1" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h4><p>测试结果：线程安全</p>
<p>分析：在Spring中，Controller的scope是singleton(单例)，也就是说在整个web系统中，只有一个TestController；但是其中注入的request却是线程安全的，原因在于：</p>
<p>使用这种方式，当Bean（本例的TestController）初始化时，Spring并没有注入一个request对象，而是注入了一个代理（proxy）；当Bean中需要使用request对象时，通过该代理获取request对象。</p>
<p>下面通过具体的代码对这一实现进行说明。</p>
<p>在上述代码中加入断点，查看request对象的属性，如下图所示：</p>
<p><img src="https://images2018.cnblogs.com/blog/1174710/201804/1174710-20180409203629380-1931318072.png" alt="img"></p>
<p>在图中可以看出，request实际上是一个代理：代理的实现参见AutowireUtils的内部类ObjectFactoryDelegatingInvocationHandler：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Reflective InvocationHandler for lazy access to the current target object.</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">private static class ObjectFactoryDelegatingInvocationHandler implements InvocationHandler, Serializable &#123;</span><br><span class="line">    private final ObjectFactory&lt;?&gt; objectFactory;</span><br><span class="line">    public ObjectFactoryDelegatingInvocationHandler(ObjectFactory&lt;?&gt; objectFactory) &#123;</span><br><span class="line">        this.objectFactory = objectFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        // ……省略无关代码</span><br><span class="line">        try &#123;</span><br><span class="line">            return method.invoke(this.objectFactory.getObject(), args); // 代理实现核心代码</span><br><span class="line">        &#125;</span><br><span class="line">        catch (InvocationTargetException ex) &#123;</span><br><span class="line">            throw ex.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，当我们调用request的方法method时，实际上是调用了由objectFactory.getObject()生成的对象的method方法；objectFactory.getObject()生成的对象才是真正的request对象。</p>
<p>继续观察上图，发现objectFactory的类型为WebApplicationContextUtils的内部类RequestObjectFactory；而RequestObjectFactory代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Factory that exposes the current request object on demand.</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;serial&quot;)</span><br><span class="line">private static class RequestObjectFactory implements ObjectFactory&lt;ServletRequest&gt;, Serializable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ServletRequest getObject() &#123;</span><br><span class="line">        return currentRequestAttributes().getRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Current HttpServletRequest&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，要获得request对象需要先调用currentRequestAttributes()方法获得RequestAttributes对象，该方法的实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Return the current RequestAttributes instance as ServletRequestAttributes.</span><br><span class="line"> */</span><br><span class="line">private static ServletRequestAttributes currentRequestAttributes() &#123;</span><br><span class="line">    RequestAttributes requestAttr = RequestContextHolder.currentRequestAttributes();</span><br><span class="line">    if (!(requestAttr instanceof ServletRequestAttributes)) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Current request is not a servlet request&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return (ServletRequestAttributes) requestAttr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成RequestAttributes对象的核心代码在类RequestContextHolder中，其中相关代码如下（省略了该类中的无关代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class RequestContextHolder &#123;</span><br><span class="line">    public static RequestAttributes currentRequestAttributes() throws IllegalStateException &#123;</span><br><span class="line">        RequestAttributes attributes = getRequestAttributes();</span><br><span class="line">        // 此处省略不相关逻辑…………</span><br><span class="line">        return attributes;</span><br><span class="line">    &#125;</span><br><span class="line">    public static RequestAttributes getRequestAttributes() &#123;</span><br><span class="line">        RequestAttributes attributes = requestAttributesHolder.get();</span><br><span class="line">        if (attributes == null) &#123;</span><br><span class="line">            attributes = inheritableRequestAttributesHolder.get();</span><br><span class="line">        &#125;</span><br><span class="line">        return attributes;</span><br><span class="line">    &#125;</span><br><span class="line">    private static final ThreadLocal&lt;RequestAttributes&gt; requestAttributesHolder =</span><br><span class="line">            new NamedThreadLocal&lt;RequestAttributes&gt;(&quot;Request attributes&quot;);</span><br><span class="line">    private static final ThreadLocal&lt;RequestAttributes&gt; inheritableRequestAttributesHolder =</span><br><span class="line">            new NamedInheritableThreadLocal&lt;RequestAttributes&gt;(&quot;Request context&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这段代码可以看出，生成的RequestAttributes对象是线程局部变量（ThreadLocal），因此request对象也是线程局部变量；这就保证了request对象的线程安全性。</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><p>该方法的主要优点：</p>
<p>1)      注入不局限于Controller中：在方法1中，只能在Controller中加入request参数。而对于方法2，不仅可以在Controller中注入，还可以在任何Bean中注入，包括Service、Repository及普通的Bean。</p>
<p>2)      注入的对象不限于request：除了注入request对象，该方法还可以注入其他scope为request或session的对象，如response对象、session对象等；并保证线程安全。</p>
<p>3)      减少代码冗余：只需要在需要request对象的Bean中注入request对象，便可以在该Bean的各个方法中使用，与方法1相比大大减少了代码冗余。</p>
<p>但是，该方法也会存在代码冗余。考虑这样的场景：web系统中有很多controller，每个controller中都会使用request对象（这种场景实际上非常频繁），这时就需要写很多次注入request的代码；如果还需要注入response，代码就更繁琐了。下面说明自动注入方法的改进方法，并分析其线程安全性及优缺点。</p>
<h3 id="方法3：基类中自动注入"><a href="#方法3：基类中自动注入" class="headerlink" title="方法3：基类中自动注入"></a><strong>方法3：基类中自动注入</strong></h3><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><p>与方法2相比，将注入部分代码放入到了基类中。</p>
<p>基类代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class BaseController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected HttpServletRequest request;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Controller代码如下；这里列举了BaseController的两个派生类，由于此时测试代码会有所不同，因此服务端测试代码没有省略；客户端也需要进行相应的修改（同时向2个url发送大量并发请求）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController extends BaseController &#123;</span><br><span class="line"></span><br><span class="line">    // 存储已有参数，用于判断参数value是否重复，从而判断线程是否安全</span><br><span class="line">    public static Set&lt;String&gt; set = new ConcurrentSkipListSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        String value = request.getParameter(&quot;key&quot;);</span><br><span class="line">        // 判断线程安全</span><br><span class="line">        if (set.contains(value)) &#123;</span><br><span class="line">            System.out.println(value + &quot;\t重复出现，request并发不安全！&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">            set.add(value);</span><br><span class="line">        &#125;</span><br><span class="line">        // 模拟程序执行了一段时间</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class Test2Controller extends BaseController &#123;</span><br><span class="line">    @RequestMapping(&quot;/test2&quot;)</span><br><span class="line">    public void test2() throws InterruptedException &#123;</span><br><span class="line">        String value = request.getParameter(&quot;key&quot;);</span><br><span class="line">        // 判断线程安全（与TestController使用一个set进行判断）</span><br><span class="line">        if (TestController.set.contains(value)) &#123;</span><br><span class="line">            System.out.println(value + &quot;\t重复出现，request并发不安全！&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">            TestController.set.add(value);</span><br><span class="line">        &#125;</span><br><span class="line">        // 模拟程序执行了一段时间</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程安全性-2"><a href="#线程安全性-2" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h4><p>测试结果：线程安全</p>
<p>分析：在理解了方法2的线程安全性的基础上，很容易理解方法3是线程安全的：当创建不同的派生类对象时，基类中的域（这里是注入的request）在不同的派生类对象中会占据不同的内存空间，也就是说将注入request的代码放在基类中对线程安全性没有任何影响；测试结果也证明了这一点。</p>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><p>与方法2相比，避免了在不同的Controller中重复注入request；但是考虑到java只允许继承一个基类，所以如果Controller需要继承其他类时，该方法便不再好用。</p>
<p>无论是方法2和方法3，都只能在Bean中注入request；如果其他方法（如工具类中static方法）需要使用request对象，则需要在调用这些方法时将request参数传递进去。下面介绍的方法4，则可以直接在诸如工具类中的static方法中使用request对象（当然在各种Bean中也可以使用）。</p>
<h3 id="方法4：手动调用"><a href="#方法4：手动调用" class="headerlink" title="方法4：手动调用"></a><strong>方法4：手动调用</strong></h3><h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        HttpServletRequest request = ((ServletRequestAttributes) (RequestContextHolder.currentRequestAttributes())).getRequest();</span><br><span class="line">        // 模拟程序执行了一段时间</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程安全性-3"><a href="#线程安全性-3" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h4><p>测试结果：线程安全</p>
<p>分析：该方法与方法2（自动注入）类似，只不过方法2中通过自动注入实现，本方法通过手动方法调用实现。因此本方法也是线程安全的。</p>
<h4 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h4><p>优点：可以在非Bean中直接获取。缺点：如果使用的地方较多，代码非常繁琐；因此可以与其他方法配合使用。</p>
<h3 id="方法5：-ModelAttribute方法"><a href="#方法5：-ModelAttribute方法" class="headerlink" title="方法5：@ModelAttribute方法"></a><strong>方法5：@ModelAttribute方法</strong></h3><h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h4><p>下面这种方法及其变种（变种：将request和bindRequest放在子类中）在网上经常见到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    private HttpServletRequest request;</span><br><span class="line">    @ModelAttribute</span><br><span class="line">    public void bindRequest(HttpServletRequest request) &#123;</span><br><span class="line">        this.request = request;</span><br><span class="line">    &#125;</span><br><span class="line">    @RequestMapping(&quot;/test&quot;)</span><br><span class="line">    public void test() throws InterruptedException &#123;</span><br><span class="line">        // 模拟程序执行了一段时间</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程安全性-4"><a href="#线程安全性-4" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h4><p>测试结果：线程不安全</p>
<p>分析：@ModelAttribute注解用在Controller中修饰方法时，其作用是Controller中的每个@RequestMapping方法执行前，该方法都会执行。因此在本例中，bindRequest()的作用是在test()执行前为request对象赋值。虽然bindRequest()中的参数request本身是线程安全的，但由于TestController是单例的，request作为TestController的一个域，无法保证线程安全。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>综上所述，Controller中加参数（方法1）、自动注入（方法2和方法3）、手动调用（方法4）都是线程安全的，都可以用来获取request对象。如果系统中request对象使用较少，则使用哪种方式均可；如果使用较多，建议使用自动注入（方法2 和方法3）来减少代码冗余。如果需要在非Bean中使用request对象，既可以在上层调用时通过参数传入，也可以直接在方法中通过手动调用（方法4）获得。</p>
<p>此外，本文在讨论获取request对象的方法时，重点讨论该方法的线程安全性、代码的繁琐程度等；在实际的开发过程中，还必须考虑所在项目的规范、代码维护等问题（此处感谢网友的批评指正）。</p>
<p><strong>参考文献</strong></p>
<ul>
<li><a href="https://docs.spring.io/spring/docs/4.1.x/spring-framework-reference/html/beans.html#beans-factory-scopes-other-injection" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/4.1.x/spring-framework-reference/html/beans.html#beans-factory-scopes-other-injection</a></li>
<li><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-methods</a></li>
<li><a href="https://stackoverflow.com/questions/10541934/spring-aop-and-aspect-thread-safety-for-an-autowired-httpservletrequest-bean" target="_blank" rel="noopener">https://stackoverflow.com/questions/10541934/spring-aop-and-aspect-thread-safety-for-an-autowired-httpservletrequest-bean</a></li>
<li><a href="http://www.phpchina.com/portal.php?mod=view&amp;aid=40966" target="_blank" rel="noopener">http://www.phpchina.com/portal.php?mod=view&amp;aid=40966</a></li>
<li><a href="https://stackoverflow.com/questions/22674044/inject-httpservletrequest-into-controller" target="_blank" rel="noopener">https://stackoverflow.com/questions/22674044/inject-httpservletrequest-into-controller</a></li>
<li><a href="https://stackoverflow.com/questions/3320674/spring-how-do-i-inject-an-httpservletrequest-into-a-request-scoped-bean" target="_blank" rel="noopener">https://stackoverflow.com/questions/3320674/spring-how-do-i-inject-an-httpservletrequest-into-a-request-scoped-bean</a></li>
<li><a href="https://my.oschina.net/sluggarddd/blog/678603?fromerr=XhvpvVTi" target="_blank" rel="noopener">https://my.oschina.net/sluggarddd/blog/678603?fromerr=XhvpvVTi</a></li>
<li><a href="https://stackoverflow.com/questions/8504258/spring-3-mvc-accessing-httprequest-from-controller" target="_blank" rel="noopener">https://stackoverflow.com/questions/8504258/spring-3-mvc-accessing-httprequest-from-controller</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/Servlet与BaseServlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/Servlet与BaseServlet/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:23+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 导入必需的 java 库</span><br><span class="line">import java.io.*;</span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line"></span><br><span class="line">// 扩展 HttpServlet 类</span><br><span class="line">public class HelloWorld extends HttpServlet &#123;</span><br><span class="line"> </span><br><span class="line">  private String message;</span><br><span class="line"></span><br><span class="line">  public void init() throws ServletException</span><br><span class="line">  &#123;</span><br><span class="line">      // 执行必需的初始化</span><br><span class="line">      message = &quot;Hello World&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void doGet(HttpServletRequest request,</span><br><span class="line">                    HttpServletResponse response)</span><br><span class="line">            throws ServletException, IOException</span><br><span class="line">  &#123;</span><br><span class="line">      // 设置响应内容类型</span><br><span class="line">      response.setContentType(&quot;text/html&quot;);</span><br><span class="line"></span><br><span class="line">      // 实际的逻辑是在这里</span><br><span class="line">      PrintWriter out = response.getWriter();</span><br><span class="line">      out.println(&quot;&lt;h1&gt;&quot; + message + &quot;&lt;/h1&gt;&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void destroy()</span><br><span class="line">  &#123;</span><br><span class="line">      // 什么也不做</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BaseServlet"><a href="#BaseServlet" class="headerlink" title="BaseServlet"></a>BaseServlet</h3><p>让service()方法去调用其他方法。例如调用add()、mod()、delele()、findAll()等方法！具体调用哪个方法需要在请求中给出方法名称！然后service()方法通过方法名称来调用指定的方法。  无论是点击超链接，还是提交表单，请求中必须要有method参数，这个参数的值就是要请求的方法名称，这样BaseServlet的service()才能通过方法名称来调用目标方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">public abstract class BaseServlet extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    public void service(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">            throws ServletException, IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">         * 1. 获取参数，用来识别用户想请求的方法</span><br><span class="line">         * 2. 然后判断是否哪一个方法，是哪一个我们就调用哪一个</span><br><span class="line">         */</span><br><span class="line">        String methodName = req.getParameter(&quot;method&quot;);</span><br><span class="line"></span><br><span class="line">        if(methodName == null || methodName.trim().isEmpty()) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;您没有传递method参数！无法确定您想要调用的方法！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 1. 得到方法名，通过方法名再得到Method类的对象！</span><br><span class="line">         *   * 需要得到Class，然后调用它的方法进行查询！得到Method</span><br><span class="line">         *   * 我们要查询的是当前类的方法，所以我们需要得到当前类的Class</span><br><span class="line">         */</span><br><span class="line">        Class&lt;? extends BaseServlet&gt; c = this.getClass();//得到当前类的class对象</span><br><span class="line">        Method method = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            method = c.getMethod(methodName, </span><br><span class="line">                    HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;您要调用的方法：&quot; + methodName + &quot;(HttpServletRequest,HttpServletResponse)，它不存在！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * 调用method表示的方法</span><br><span class="line">         */</span><br><span class="line">        try &#123;</span><br><span class="line">            String result = (String)method.invoke(this, req, resp);</span><br><span class="line">            /*</span><br><span class="line">             * 获取请求处理方法执行后返回的字符串，它表示转发或重定向的路径！</span><br><span class="line">             * 如果用户返回的是字符串为null，或为&quot;&quot;，那么什么也不做！</span><br><span class="line">             */</span><br><span class="line">            if(result == null || result.trim().isEmpty()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            /*</span><br><span class="line">             * 查看返回的字符串中是否包含冒号，如果没有，表示转发</span><br><span class="line">             * 如果有，使用冒号分割字符串，得到前缀和后缀！</span><br><span class="line">             * 其中前缀如果是f，表示转发，如果是r表示重定向，后缀就是要转发或重定向的路径了！</span><br><span class="line">             */</span><br><span class="line">            if(result.contains(&quot;:&quot;)) &#123;</span><br><span class="line">                // 使用冒号分割字符串，得到前缀和后缀</span><br><span class="line">                String str[] = result.split(&quot;:&quot;);//用冒号分割字符串</span><br><span class="line">                String s = str[0];//取出前缀，表示操作</span><br><span class="line">                String path = str[1];//取出后缀，表示路径</span><br><span class="line">                if(s.equalsIgnoreCase(&quot;r&quot;)) &#123;//如果前缀是r，那么重定向！</span><br><span class="line">                    resp.sendRedirect(req.getContextPath() + path);</span><br><span class="line">                &#125; else if(s.equalsIgnoreCase(&quot;f&quot;)) &#123;</span><br><span class="line">                    req.getRequestDispatcher(path).forward(req, resp);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new RuntimeException(&quot;你指定的操作：&quot; + s + &quot;，当前版本还不支持！&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;//没有冒号，默认为转发！</span><br><span class="line">                req.getRequestDispatcher(result).forward(req, resp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            System.out.println(&quot;您调用的方法：&quot; + methodName + &quot;,　它内部抛出了异常！&quot;);</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java后端/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李楚豪的博客">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java后端/Redis/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T00:15:22+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis是一个高性能的key-value数据库。</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<ol>
<li>Redis支持数据的持久化，可以将内存中的数据保存到硬盘中，重启时可以再次加载进行使用。</li>
<li>Redis还支持key-list、key-set、key-hash、key-zset(sorted set：有序集合)等数据结构的存储。</li>
<li>支持数据的备份，即master-slave 模式的数据备份。</li>
</ol>
<h2 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h2><ul>
<li><strong>性能极高</strong> – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li><strong>丰富的数据类型</strong> – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li><strong>原子</strong> – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li><strong>丰富的特性</strong> – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line">PONG</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET runoobkey redis</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; GET runoobkey</span><br><span class="line">&quot;redis&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Redis-发布订阅-pub-sub"><a href="#Redis-发布订阅-pub-sub" class="headerlink" title="Redis 发布订阅(pub/sub)"></a>Redis 发布订阅(pub/sub)</h3><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png" alt="pubsub1"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/11/pubsub2.png" alt="pubsub2"></p>
<h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
<p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">李楚豪的博客</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">85</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李楚豪的博客</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
